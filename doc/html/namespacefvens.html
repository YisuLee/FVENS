<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FVENS: fvens Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FVENS
   </div>
   <div id="projectbrief">An 2D unstructured finite volume compressible flow solver</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">fvens Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1Adiabaticwall.html">Adiabaticwall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General adiabatic wall suitable for geometry in Cartesian coordinates.  <a href="classfvens_1_1Adiabaticwall.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1Adiabaticwall2D.html">Adiabaticwall2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-slip adiabatic wall BC for 2D NS equations.  <a href="classfvens_1_1Adiabaticwall2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1Array2d.html">Array2d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a dense 2D row-major array.  <a href="classfvens_1_1Array2d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1AUSMFlux.html">AUSMFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Liou-Steffen AUSM flux-vector-splitting.  <a href="classfvens_1_1AUSMFlux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1AUSMPlusFlux.html">AUSMPlusFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Liou's AUSM+ flux.  <a href="classfvens_1_1AUSMPlusFlux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1BarthJespersenLimiter.html">BarthJespersenLimiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-differentiable multidimensional slope limiter for linear reconstruction.  <a href="classfvens_1_1BarthJespersenLimiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1ConstGhostedVecHandler.html">ConstGhostedVecHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains an immutable native array corresponding to a ghosted PETSc Vec and provides access.  <a href="classfvens_1_1ConstGhostedVecHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1ConstVecHandler.html">ConstVecHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains an immutable native array corresponding to a PETSc Vec and provides access.  <a href="classfvens_1_1ConstVecHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1Diffusion.html">Diffusion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfvens_1_1Spatial.html" title="Base class for finite volume spatial discretization.">Spatial</a> discretization of diffusion operator with constant difusivity.  <a href="classfvens_1_1Diffusion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1DiffusionMA.html">DiffusionMA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1Extrapolation.html">Extrapolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply sets the ghost state as the interior state.  <a href="classfvens_1_1Extrapolation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1Farfield.html">Farfield</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply sets the ghost state as the given free-stream state.  <a href="classfvens_1_1Farfield.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1FlowBC.html">FlowBC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for storing the details and providing functionality for one type if BC.  <a href="classfvens_1_1FlowBC.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfvens_1_1FlowBCConfig.html">FlowBCConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of boundary condition at one particular boundary.  <a href="structfvens_1_1FlowBCConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1FlowCase.html">FlowCase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a flow problem, either steady or unsteady, with conditions specified in the FVENS control file.  <a href="classfvens_1_1FlowCase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1FlowFV.html">FlowFV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the integrated fluxes and their Jacobians for compressible flow.  <a href="classfvens_1_1FlowFV.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1FlowFV__base.html">FlowFV_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for finite volume discretization of flow problems.  <a href="classfvens_1_1FlowFV__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfvens_1_1FlowNumericsConfig.html">FlowNumericsConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of options related to the spatial discretization scheme.  <a href="structfvens_1_1FlowNumericsConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1FlowOutput.html">FlowOutput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfvens_1_1Output.html" title="Interface for output to files.">Output</a> for flow simulations.  <a href="classfvens_1_1FlowOutput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfvens_1_1FlowParserOptions.html">FlowParserOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data read from a control file for flow problems.  <a href="structfvens_1_1FlowParserOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfvens_1_1FlowPhysicsConfig.html">FlowPhysicsConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The collection of physical data needed to initialize flow spatial discretizations.  <a href="structfvens_1_1FlowPhysicsConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1FlowSimpleUpdate.html">FlowSimpleUpdate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfvens_1_1FlowSolutionFunctionals.html">FlowSolutionFunctionals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrated quantities of interest in the solution of a flow problem.  <a href="structfvens_1_1FlowSolutionFunctionals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1FullUpdate.html">FullUpdate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial relaxation factor of constant 1.  <a href="classfvens_1_1FullUpdate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1GradientScheme.html">GradientScheme</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for solution gradient computation schemes.  <a href="classfvens_1_1GradientScheme.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfvens_1_1GraphVertex.html">GraphVertex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfvens_1_1GraphVertices.html">GraphVertices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Details needed.  <a href="structfvens_1_1GraphVertices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1GreenGaussGradients.html">GreenGaussGradients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements linear reconstruction using the Green-Gauss theorem over elements.  <a href="classfvens_1_1GreenGaussGradients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1HLLCFlux.html">HLLCFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Harten Lax Van-Leer numerical flux with contact restoration by Toro.  <a href="classfvens_1_1HLLCFlux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1HLLFlux.html">HLLFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Harten Lax Van-Leer numerical flux.  <a href="classfvens_1_1HLLFlux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow-physics-related computation for single-phase ideal gas.  <a href="classfvens_1_1IdealGasPhysics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1InFlow.html">InFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal subsonic inflow BC with total pressure and total temperature specified.  <a href="classfvens_1_1InFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1InOutFlow.html">InOutFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently, this is a pressure-imposed outflow and all-imposed inflow BC.  <a href="classfvens_1_1InOutFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1InputNotGivenError.html">InputNotGivenError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when a required input was not provided.  <a href="classfvens_1_1InputNotGivenError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1InviscidFlux.html">InviscidFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class from which to derive all numerical flux classes.  <a href="classfvens_1_1InviscidFlux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1Isothermalwall2D.html">Isothermalwall2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-slip isothermal wall BC for 2D NS equations.  <a href="classfvens_1_1Isothermalwall2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1L2TraceVector.html">L2TraceVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A distributed vector belonging to the trace space of a discontinuous function defined on a mesh.  <a href="classfvens_1_1L2TraceVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1LinearUnlimitedReconstruction.html">LinearUnlimitedReconstruction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfvens_1_1LineConfig.html">LineConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of lines in the mesh.  <a href="structfvens_1_1LineConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfvens_1_1ListOfArrays.html">ListOfArrays</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of arrays implemented as one long contiguous array.  <a href="structfvens_1_1ListOfArrays.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfvens_1_1ListsOfArrays.html">ListsOfArrays</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of lists of arrays sharing the same topology determined by one array of pointers.  <a href="structfvens_1_1ListsOfArrays.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfvens_1_1LocalAnisotropies.html">LocalAnisotropies</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1LocalLaxFriedrichsFlux.html">LocalLaxFriedrichsFlux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1MatrixFreeSpatialJacobian.html">MatrixFreeSpatialJacobian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix-free Jacobian of the flux.  <a href="classfvens_1_1MatrixFreeSpatialJacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfvens_1_1MeshData.html">MeshData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data which is read from a mesh file.  <a href="structfvens_1_1MeshData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1MPI__exception.html">MPI_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown due to return codes from MPI functions.  <a href="classfvens_1_1MPI__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1MUSCLReconstruction.html">MUSCLReconstruction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides common functionality for computing face values using MUSCL reconstruciton.  <a href="classfvens_1_1MUSCLReconstruction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1MUSCLVanAlbada.html">MUSCLVanAlbada</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes face values using MUSCL reconstruciton with Van-Albada limiter.  <a href="classfvens_1_1MUSCLVanAlbada.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1MutableGhostedVecHandler.html">MutableGhostedVecHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains an immutable native array corresponding to a ghosted PETSc Vec and provides access.  <a href="classfvens_1_1MutableGhostedVecHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1MutableVecHandler.html">MutableVecHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains a native array corresponding to a PETSc Vec and provides access.  <a href="classfvens_1_1MutableVecHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1NonlinearUpdate.html">NonlinearUpdate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for computation of a (local) relaxation factor given a state and an update.  <a href="classfvens_1_1NonlinearUpdate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1Numerical__error.html">Numerical_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception to throw on errors related to numerics.  <a href="classfvens_1_1Numerical__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1Output.html">Output</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for output to files.  <a href="classfvens_1_1Output.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1Petsc__exception.html">Petsc_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception to throw for errors from PETSc; takes a custom message.  <a href="classfvens_1_1Petsc__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1Physics.html">Physics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class providing analytical fluxes and their Jacobians etc.  <a href="classfvens_1_1Physics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1ReplicatedGlobalMeshPartitioner.html">ReplicatedGlobalMeshPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory-inefficient partitioner that assumes the global mesh is available on all partitions.  <a href="classfvens_1_1ReplicatedGlobalMeshPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1RoeAverageBasedFlux.html">RoeAverageBasedFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for fluxes which depend on Roe-averages.  <a href="classfvens_1_1RoeAverageBasedFlux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1RoeFlux.html">RoeFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Roe-Pike flux-difference splitting.  <a href="classfvens_1_1RoeFlux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1ScotchRGMPartitioner.html">ScotchRGMPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple partitioner that just serially partitions the mesh using Scotch.  <a href="classfvens_1_1ScotchRGMPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1Slipwall.html">Slipwall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slip wall BC for Euler equations.  <a href="classfvens_1_1Slipwall.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1SolutionReconstruction.html">SolutionReconstruction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for computing face values from cell-centered values and gradients.  <a href="classfvens_1_1SolutionReconstruction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1Spatial.html">Spatial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for finite volume spatial discretization.  <a href="classfvens_1_1Spatial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1SteadyBackwardEulerSolver.html">SteadyBackwardEulerSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit pseudo-time iteration to steady state.  <a href="classfvens_1_1SteadyBackwardEulerSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1SteadyFlowCase.html">SteadyFlowCase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution procedure for a steady-state case.  <a href="classfvens_1_1SteadyFlowCase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1SteadyForwardEulerSolver.html">SteadyForwardEulerSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A driver class for explicit time-stepping to steady state using forward Euler integration.  <a href="classfvens_1_1SteadyForwardEulerSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1SteadySolver.html">SteadySolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for steady-state simulations in pseudo-time.  <a href="classfvens_1_1SteadySolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfvens_1_1SteadySolverConfig.html">SteadySolverConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of parameters specifying the temporal discretization.  <a href="structfvens_1_1SteadySolverConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfvens_1_1SteadyStepMonitor.html">SteadyStepMonitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data written out to file for each pseudo-time step, if requested.  <a href="structfvens_1_1SteadyStepMonitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfvens_1_1TimingData.html">TimingData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of variables used for benchmarking purposes.  <a href="structfvens_1_1TimingData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1Tolerance__error.html">Tolerance_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when some solver does not meet the required tolerance.  <a href="classfvens_1_1Tolerance__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1TrivialReplicatedGlobalMeshPartitioner.html">TrivialReplicatedGlobalMeshPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions the mesh trivially based on the initial global element ordering.  <a href="classfvens_1_1TrivialReplicatedGlobalMeshPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1TVDRKSolver.html">TVDRKSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total variation diminishing Runge-Kutta solvers upto order 3.  <a href="classfvens_1_1TVDRKSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1UMesh.html">UMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hybrid unstructured mesh class supporting triangular and quadrangular elements.  <a href="classfvens_1_1UMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1UnsteadyFlowCase.html">UnsteadyFlowCase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution procedure for an unsteady flow case.  <a href="classfvens_1_1UnsteadyFlowCase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1UnsteadySolver.html">UnsteadySolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for unsteady simulations.  <a href="classfvens_1_1UnsteadySolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1UnsupportedOptionError.html">UnsupportedOptionError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when a user-supplied option is invalid.  <a href="classfvens_1_1UnsupportedOptionError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1VanLeerFlux.html">VanLeerFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Van-Leer flux-vector-splitting.  <a href="classfvens_1_1VanLeerFlux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1VenkatakrishnanLimiter.html">VenkatakrishnanLimiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Differentiable modification of Barth-Jespersen limiter.  <a href="classfvens_1_1VenkatakrishnanLimiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1WeightedLeastSquaresGradients.html">WeightedLeastSquaresGradients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing linear weighted least-squares reconstruction.  <a href="classfvens_1_1WeightedLeastSquaresGradients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1WENOReconstruction.html">WENOReconstruction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfvens_1_1ZeroGradients.html">ZeroGradients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply sets the gradient to zero.  <a href="classfvens_1_1ZeroGradients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad45362403189f6d521a8f6c00a101fc3" id="r_ad45362403189f6d521a8f6c00a101fc3"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a></td></tr>
<tr class="memdesc:ad45362403189f6d521a8f6c00a101fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The floating-point type to use for all float computations.  <br /></td></tr>
<tr class="separator:ad45362403189f6d521a8f6c00a101fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebf89314ef9893bfb577bc1551f8f9c" id="r_aaebf89314ef9893bfb577bc1551f8f9c"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaebf89314ef9893bfb577bc1551f8f9c">fint</a></td></tr>
<tr class="memdesc:aaebf89314ef9893bfb577bc1551f8f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer type to use for indexing etc.  <br /></td></tr>
<tr class="separator:aaebf89314ef9893bfb577bc1551f8f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef2a13f3be4eb2286c21012175727a2" id="r_a5ef2a13f3be4eb2286c21012175727a2"><td class="memTemplParams" colspan="2"><a id="a5ef2a13f3be4eb2286c21012175727a2" name="a5ef2a13f3be4eb2286c21012175727a2"></a>
template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a5ef2a13f3be4eb2286c21012175727a2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MVector</b> = Eigen::Matrix&lt;scalar, Eigen::Dynamic,Eigen::Dynamic,Eigen::RowMajor&gt;</td></tr>
<tr class="memdesc:a5ef2a13f3be4eb2286c21012175727a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-vector type, used for storing mesh functions like the residual. <br /></td></tr>
<tr class="separator:a5ef2a13f3be4eb2286c21012175727a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a35881a045a640494a8d4fb72b3c5d0" id="r_a7a35881a045a640494a8d4fb72b3c5d0"><td class="memTemplParams" colspan="2">template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a7a35881a045a640494a8d4fb72b3c5d0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a35881a045a640494a8d4fb72b3c5d0">DimMatrixArray</a></td></tr>
<tr class="memdesc:a7a35881a045a640494a8d4fb72b3c5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of fixed-size Eigen matrices each with the number of space dimensions as the size.  <br /></td></tr>
<tr class="separator:a7a35881a045a640494a8d4fb72b3c5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e1760d87ddd0b362f2cc20dbb9ac8f" id="r_a66e1760d87ddd0b362f2cc20dbb9ac8f"><td class="memTemplParams" colspan="2"><a id="a66e1760d87ddd0b362f2cc20dbb9ac8f" name="a66e1760d87ddd0b362f2cc20dbb9ac8f"></a>
template&lt;typename scalar, int ndim, int nvars&gt; </td></tr>
<tr class="memitem:a66e1760d87ddd0b362f2cc20dbb9ac8f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GradBlock_t</b> = Eigen::Array&lt;scalar,ndim,nvars,Eigen::ColMajor|Eigen::DontAlign&gt;</td></tr>
<tr class="memdesc:a66e1760d87ddd0b362f2cc20dbb9ac8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed-size Eigen array for storing things like the spatial gradient of a vector field. <br /></td></tr>
<tr class="separator:a66e1760d87ddd0b362f2cc20dbb9ac8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4b3b34266f058dfacb80a0899efa24" id="r_a7f4b3b34266f058dfacb80a0899efa24"><td class="memItemLeft" align="right" valign="top"><a id="a7f4b3b34266f058dfacb80a0899efa24" name="a7f4b3b34266f058dfacb80a0899efa24"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>StatusCode</b></td></tr>
<tr class="memdesc:a7f4b3b34266f058dfacb80a0899efa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data type for error codes, mostly for use with PETSc. <br /></td></tr>
<tr class="separator:a7f4b3b34266f058dfacb80a0899efa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9fd89aa04de68787618c1ccf089954" id="r_abe9fd89aa04de68787618c1ccf089954"><td class="memItemLeft" align="right" valign="top"><a id="abe9fd89aa04de68787618c1ccf089954" name="abe9fd89aa04de68787618c1ccf089954"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>EIndex</b></td></tr>
<tr class="memdesc:abe9fd89aa04de68787618c1ccf089954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of something w.r.t. the element it is associated with. <br /></td></tr>
<tr class="separator:abe9fd89aa04de68787618c1ccf089954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d78b9813427e80e79f3b7eb9ba66b1" id="r_a64d78b9813427e80e79f3b7eb9ba66b1"><td class="memItemLeft" align="right" valign="top"><a id="a64d78b9813427e80e79f3b7eb9ba66b1" name="a64d78b9813427e80e79f3b7eb9ba66b1"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>FIndex</b></td></tr>
<tr class="memdesc:a64d78b9813427e80e79f3b7eb9ba66b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of something (usually a node) w.r.t. the face it is associated with. <br /></td></tr>
<tr class="separator:a64d78b9813427e80e79f3b7eb9ba66b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c690dd36dbd2ff4e4bf64d1c328fbc8" id="r_a2c690dd36dbd2ff4e4bf64d1c328fbc8"><td class="memTemplParams" colspan="2"><a id="a2c690dd36dbd2ff4e4bf64d1c328fbc8" name="a2c690dd36dbd2ff4e4bf64d1c328fbc8"></a>
template&lt;typename scalar, int nvars&gt; </td></tr>
<tr class="memitem:a2c690dd36dbd2ff4e4bf64d1c328fbc8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FMultiVectorArray</b> = std::vector&lt;Eigen::Matrix&lt;scalar,<a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a>,nvars,Eigen::DontAlign&gt;&gt;</td></tr>
<tr class="separator:a2c690dd36dbd2ff4e4bf64d1c328fbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a56fad6cc480ce18470ad2623ce90708e" id="r_a56fad6cc480ce18470ad2623ce90708e"><td class="memItemLeft" align="right" valign="top"><a id="a56fad6cc480ce18470ad2623ce90708e" name="a56fad6cc480ce18470ad2623ce90708e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56fad6cc480ce18470ad2623ce90708e">BCType</a> { <br />
&#160;&#160;<b>SLIP_WALL_BC</b>
, <b>FARFIELD_BC</b>
, <b>INFLOW_OUTFLOW_BC</b>
, <b>SUBSONIC_INFLOW_BC</b>
, <br />
&#160;&#160;<b>EXTRAPOLATION_BC</b>
, <b>PERIODIC_BC</b>
, <b>ISOTHERMAL_WALL_BC</b>
, <b>ADIABATIC_WALL_BC</b>
<br />
 }</td></tr>
<tr class="memdesc:a56fad6cc480ce18470ad2623ce90708e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The types of boundary condition a boundary face can have. <br /></td></tr>
<tr class="separator:a56fad6cc480ce18470ad2623ce90708e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a87df369a5f08b7cabc1d8e8acc3b5018" id="r_a87df369a5f08b7cabc1d8e8acc3b5018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87df369a5f08b7cabc1d8e8acc3b5018">createSystemVector</a> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const int nvars, Vec *const v)</td></tr>
<tr class="memdesc:a87df369a5f08b7cabc1d8e8acc3b5018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Vec with one unknown per mesh cell.  <br /></td></tr>
<tr class="separator:a87df369a5f08b7cabc1d8e8acc3b5018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721b6f991550d7f5dac681acd2986ffe" id="r_a721b6f991550d7f5dac681acd2986ffe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a721b6f991550d7f5dac681acd2986ffe">createGhostedSystemVector</a> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const int nvars, Vec *const v)</td></tr>
<tr class="memdesc:a721b6f991550d7f5dac681acd2986ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up global vectors with storage with ghost locations for connectivity boundaries.  <br /></td></tr>
<tr class="separator:a721b6f991550d7f5dac681acd2986ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c5144f6169bad3c8c04f5bf11506eb" id="r_a75c5144f6169bad3c8c04f5bf11506eb"><td class="memTemplParams" colspan="2"><a id="a75c5144f6169bad3c8c04f5bf11506eb" name="a75c5144f6169bad3c8c04f5bf11506eb"></a>
template&lt;int nvars&gt; </td></tr>
<tr class="memitem:a75c5144f6169bad3c8c04f5bf11506eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setJacobianPreallocation</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, Mat A)</td></tr>
<tr class="memdesc:a75c5144f6169bad3c8c04f5bf11506eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the amount of memory to be reserved for the Jacobian matrix. <br /></td></tr>
<tr class="separator:a75c5144f6169bad3c8c04f5bf11506eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61194894d83a3464df6b20465b9cbd4e" id="r_a61194894d83a3464df6b20465b9cbd4e"><td class="memItemLeft" align="right" valign="top"><a id="a61194894d83a3464df6b20465b9cbd4e" name="a61194894d83a3464df6b20465b9cbd4e"></a>
template <a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>setJacobianPreallocation&lt; 1 &gt;</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, Mat A)</td></tr>
<tr class="separator:a61194894d83a3464df6b20465b9cbd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2433008b1beecde4a913b13440d76246" id="r_a2433008b1beecde4a913b13440d76246"><td class="memItemLeft" align="right" valign="top"><a id="a2433008b1beecde4a913b13440d76246" name="a2433008b1beecde4a913b13440d76246"></a>
template <a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>setJacobianPreallocation&lt; NVARS &gt;</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, Mat A)</td></tr>
<tr class="separator:a2433008b1beecde4a913b13440d76246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb6c0d2e0e53a2f95307404a8bf14c7" id="r_adeb6c0d2e0e53a2f95307404a8bf14c7"><td class="memTemplParams" colspan="2">template&lt;int nvars&gt; </td></tr>
<tr class="memitem:adeb6c0d2e0e53a2f95307404a8bf14c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adeb6c0d2e0e53a2f95307404a8bf14c7">setupSystemMatrix</a> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, Mat *const A)</td></tr>
<tr class="memdesc:adeb6c0d2e0e53a2f95307404a8bf14c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up storage preallocation for sparse matrix formats.  <br /></td></tr>
<tr class="separator:adeb6c0d2e0e53a2f95307404a8bf14c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f50a06f80fdde5c9ea907e2d650cf48" id="r_a1f50a06f80fdde5c9ea907e2d650cf48"><td class="memItemLeft" align="right" valign="top"><a id="a1f50a06f80fdde5c9ea907e2d650cf48" name="a1f50a06f80fdde5c9ea907e2d650cf48"></a>
template <a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>setupSystemMatrix&lt; NVARS &gt;</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, Mat *const A)</td></tr>
<tr class="separator:a1f50a06f80fdde5c9ea907e2d650cf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399a3102e97c1b63794c835421642a35" id="r_a399a3102e97c1b63794c835421642a35"><td class="memItemLeft" align="right" valign="top"><a id="a399a3102e97c1b63794c835421642a35" name="a399a3102e97c1b63794c835421642a35"></a>
template <a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>setupSystemMatrix&lt; 1 &gt;</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, Mat *const A)</td></tr>
<tr class="separator:a399a3102e97c1b63794c835421642a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe5ec218fc6343b6f030639fcf2ffb5" id="r_adfe5ec218fc6343b6f030639fcf2ffb5"><td class="memTemplParams" colspan="2"><a id="adfe5ec218fc6343b6f030639fcf2ffb5" name="adfe5ec218fc6343b6f030639fcf2ffb5"></a>
template&lt;int nvars&gt; </td></tr>
<tr class="memitem:adfe5ec218fc6343b6f030639fcf2ffb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>matrixfree_apply</b> (Mat A, Vec x, Vec y)</td></tr>
<tr class="memdesc:adfe5ec218fc6343b6f030639fcf2ffb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function called by PETSc to carry out a Jacobian-vector product. <br /></td></tr>
<tr class="separator:adfe5ec218fc6343b6f030639fcf2ffb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cbd8d7db386fb54e230ebac8fd51d3" id="r_a61cbd8d7db386fb54e230ebac8fd51d3"><td class="memTemplParams" colspan="2"><a id="a61cbd8d7db386fb54e230ebac8fd51d3" name="a61cbd8d7db386fb54e230ebac8fd51d3"></a>
template&lt;int nvars&gt; </td></tr>
<tr class="memitem:a61cbd8d7db386fb54e230ebac8fd51d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>matrixfree_destroy</b> (Mat A)</td></tr>
<tr class="memdesc:a61cbd8d7db386fb54e230ebac8fd51d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called by PETSc to cleanup the matrix-free mat. <br /></td></tr>
<tr class="separator:a61cbd8d7db386fb54e230ebac8fd51d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbed4f807cbfd710dc987267d6e5a7a" id="r_a6fbed4f807cbfd710dc987267d6e5a7a"><td class="memTemplParams" colspan="2">template&lt;int nvars&gt; </td></tr>
<tr class="memitem:a6fbed4f807cbfd710dc987267d6e5a7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6fbed4f807cbfd710dc987267d6e5a7a">create_matrixfree_jacobian</a> (const <a class="el" href="classfvens_1_1Spatial.html">Spatial</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, nvars &gt; *const spatial, Mat *const A)</td></tr>
<tr class="memdesc:a6fbed4f807cbfd710dc987267d6e5a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup a matrix-free Mat for the Jacobian.  <br /></td></tr>
<tr class="separator:a6fbed4f807cbfd710dc987267d6e5a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634d629d1b4ad5efd732ce5b46fc97b0" id="r_a634d629d1b4ad5efd732ce5b46fc97b0"><td class="memItemLeft" align="right" valign="top"><a id="a634d629d1b4ad5efd732ce5b46fc97b0" name="a634d629d1b4ad5efd732ce5b46fc97b0"></a>
template <a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_matrixfree_jacobian&lt; NVARS &gt;</b> (const <a class="el" href="classfvens_1_1Spatial.html">Spatial</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a> &gt; *const s, Mat *const A)</td></tr>
<tr class="separator:a634d629d1b4ad5efd732ce5b46fc97b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9628061ca36c21183870024dc1918ddd" id="r_a9628061ca36c21183870024dc1918ddd"><td class="memItemLeft" align="right" valign="top"><a id="a9628061ca36c21183870024dc1918ddd" name="a9628061ca36c21183870024dc1918ddd"></a>
template <a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_matrixfree_jacobian&lt; 1 &gt;</b> (const <a class="el" href="classfvens_1_1Spatial.html">Spatial</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, 1 &gt; *const s, Mat *const A)</td></tr>
<tr class="separator:a9628061ca36c21183870024dc1918ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564dbfe12fcbec2c87ce049846bb6f6b" id="r_a564dbfe12fcbec2c87ce049846bb6f6b"><td class="memItemLeft" align="right" valign="top"><a id="a564dbfe12fcbec2c87ce049846bb6f6b" name="a564dbfe12fcbec2c87ce049846bb6f6b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isMatrixFree</b> (Mat)</td></tr>
<tr class="memdesc:a564dbfe12fcbec2c87ce049846bb6f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the argument is a matrix-free PETSc Mat. <br /></td></tr>
<tr class="separator:a564dbfe12fcbec2c87ce049846bb6f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531394abf855c7a719a1885f575b6f65" id="r_a531394abf855c7a719a1885f575b6f65"><td class="memItemLeft" align="right" valign="top"><a id="a531394abf855c7a719a1885f575b6f65" name="a531394abf855c7a719a1885f575b6f65"></a>
<a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPC</b> (KSP ksp, const char *const type_name, PC *pcfound)</td></tr>
<tr class="memdesc:a531394abf855c7a719a1885f575b6f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive function to return the first occurrence if a specific type of PC. <br /></td></tr>
<tr class="separator:a531394abf855c7a719a1885f575b6f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50922fdd203348456f295315f80d11a" id="r_ae50922fdd203348456f295315f80d11a"><td class="memTemplParams" colspan="2"><a id="ae50922fdd203348456f295315f80d11a" name="ae50922fdd203348456f295315f80d11a"></a>
template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:ae50922fdd203348456f295315f80d11a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zeros</b> (scalar *const __restrict a, const <a class="el" href="#aaebf89314ef9893bfb577bc1551f8f9c">fint</a> n)</td></tr>
<tr class="memdesc:ae50922fdd203348456f295315f80d11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a raw array of scalars with zeros. <br /></td></tr>
<tr class="separator:ae50922fdd203348456f295315f80d11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd89b6eeb369a5480627c426f050d58a" id="r_abd89b6eeb369a5480627c426f050d58a"><td class="memTemplParams" colspan="2"><a id="abd89b6eeb369a5480627c426f050d58a" name="abd89b6eeb369a5480627c426f050d58a"></a>
template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:abd89b6eeb369a5480627c426f050d58a"><td class="memTemplItemLeft" align="right" valign="top">scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dimDotProduct</b> (const scalar *const u, const scalar *const v)</td></tr>
<tr class="memdesc:abd89b6eeb369a5480627c426f050d58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a dot product computed between the first NDIM components of the two vectors. <br /></td></tr>
<tr class="separator:abd89b6eeb369a5480627c426f050d58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2aea8606c84e108e550d97a8fce148" id="r_abb2aea8606c84e108e550d97a8fce148"><td class="memTemplParams" colspan="2">template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:abb2aea8606c84e108e550d97a8fce148"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abb2aea8606c84e108e550d97a8fce148">getComponentsCartesian</a> (const scalar mag, const scalar dir[<a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a>], scalar vec[<a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a>])</td></tr>
<tr class="separator:abb2aea8606c84e108e550d97a8fce148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7203e773c9efc1df783a28bded7859ca" id="r_a7203e773c9efc1df783a28bded7859ca"><td class="memTemplParams" colspan="2">template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a7203e773c9efc1df783a28bded7859ca"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7203e773c9efc1df783a28bded7859ca">getNormalizedFreeStreamVector</a> (const scalar aoa, const scalar beta)</td></tr>
<tr class="memdesc:a7203e773c9efc1df783a28bded7859ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unit vector along free-stream direction.  <br /></td></tr>
<tr class="separator:a7203e773c9efc1df783a28bded7859ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1040148dc4a6ca117ec289fc83a507" id="r_acf1040148dc4a6ca117ec289fc83a507"><td class="memTemplParams" colspan="2">template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:acf1040148dc4a6ca117ec289fc83a507"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acf1040148dc4a6ca117ec289fc83a507">getQuotientDerivatives</a> (const scalar f, const scalar *const df, const scalar g, const scalar *const dg, scalar *const __restrict dq)</td></tr>
<tr class="memdesc:acf1040148dc4a6ca117ec289fc83a507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the derivatives of f/g given the derivatives of f and g (for NVARS components)  <br /></td></tr>
<tr class="separator:acf1040148dc4a6ca117ec289fc83a507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40ac6eb781856a50a9d37bf3d505084" id="r_aa40ac6eb781856a50a9d37bf3d505084"><td class="memTemplParams" colspan="2"><a id="aa40ac6eb781856a50a9d37bf3d505084" name="aa40ac6eb781856a50a9d37bf3d505084"></a>
template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:aa40ac6eb781856a50a9d37bf3d505084"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preprocessMesh</b> (<a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;m)</td></tr>
<tr class="separator:aa40ac6eb781856a50a9d37bf3d505084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330645088ee7de1113cf50e7d738df74" id="r_a330645088ee7de1113cf50e7d738df74"><td class="memItemLeft" align="right" valign="top"><a id="a330645088ee7de1113cf50e7d738df74" name="a330645088ee7de1113cf50e7d738df74"></a>
<a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>constructMesh</b> (const std::string mesh_path)</td></tr>
<tr class="memdesc:a330645088ee7de1113cf50e7d738df74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ready-to-use mesh object from the path to mesh file. <br /></td></tr>
<tr class="separator:a330645088ee7de1113cf50e7d738df74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4d34891d7ddf03c736829dcb359d14" id="r_a3d4d34891d7ddf03c736829dcb359d14"><td class="memTemplParams" colspan="2"><a id="a3d4d34891d7ddf03c736829dcb359d14" name="a3d4d34891d7ddf03c736829dcb359d14"></a>
template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a3d4d34891d7ddf03c736829dcb359d14"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="#aaebf89314ef9893bfb577bc1551f8f9c">fint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>levelSchedule</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;m)</td></tr>
<tr class="separator:a3d4d34891d7ddf03c736829dcb359d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75827e37348b3420478d170e43fe08af" id="r_a75827e37348b3420478d170e43fe08af"><td class="memItemLeft" align="right" valign="top"><a id="a75827e37348b3420478d170e43fe08af" name="a75827e37348b3420478d170e43fe08af"></a>
std::array&lt; bool, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>compareMeshes</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;m1, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;m2)</td></tr>
<tr class="separator:a75827e37348b3420478d170e43fe08af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825aed6e96e3c9d13d908980a6f333c5" id="r_a825aed6e96e3c9d13d908980a6f333c5"><td class="memTemplParams" colspan="2">template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a825aed6e96e3c9d13d908980a6f333c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a825aed6e96e3c9d13d908980a6f333c5">reorderMeshPetsc</a> (const char *const ordering, const <a class="el" href="classfvens_1_1Spatial.html">Spatial</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, 1 &gt; &amp;sd, <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;m)</td></tr>
<tr class="memdesc:a825aed6e96e3c9d13d908980a6f333c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the mesh cells in a given ordering using PETSc.  <br /></td></tr>
<tr class="separator:a825aed6e96e3c9d13d908980a6f333c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acced052c0b2e713eb4809ffea833ab11" id="r_acced052c0b2e713eb4809ffea833ab11"><td class="memItemLeft" align="right" valign="top"><a id="acced052c0b2e713eb4809ffea833ab11" name="acced052c0b2e713eb4809ffea833ab11"></a>
template <a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>preprocessMesh</b> (<a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;m)</td></tr>
<tr class="separator:acced052c0b2e713eb4809ffea833ab11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d5d01c15fa5f8249ffae277cdf3657" id="r_aa9d5d01c15fa5f8249ffae277cdf3657"><td class="memItemLeft" align="right" valign="top"><a id="aa9d5d01c15fa5f8249ffae277cdf3657" name="aa9d5d01c15fa5f8249ffae277cdf3657"></a>
template std::vector&lt; <a class="el" href="#aaebf89314ef9893bfb577bc1551f8f9c">fint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>levelSchedule</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;m)</td></tr>
<tr class="separator:aa9d5d01c15fa5f8249ffae277cdf3657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5afd2a89ff132e171e8abec92062b58" id="r_af5afd2a89ff132e171e8abec92062b58"><td class="memTemplParams" colspan="2">template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:af5afd2a89ff132e171e8abec92062b58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5afd2a89ff132e171e8abec92062b58">preprocessMesh</a> (<a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, 2 &gt; &amp;m)</td></tr>
<tr class="memdesc:af5afd2a89ff132e171e8abec92062b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes various entity lists required for mesh traversal, also reorders the cells if requested.  <br /></td></tr>
<tr class="separator:af5afd2a89ff132e171e8abec92062b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbefb568aed4483bc28fc6cc4497914" id="r_a0cbefb568aed4483bc28fc6cc4497914"><td class="memTemplParams" colspan="2">template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a0cbefb568aed4483bc28fc6cc4497914"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="#aaebf89314ef9893bfb577bc1551f8f9c">fint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0cbefb568aed4483bc28fc6cc4497914">levelSchedule</a> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, 2 &gt; &amp;m)</td></tr>
<tr class="memdesc:a0cbefb568aed4483bc28fc6cc4497914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides mesh cells into levels within each of which no cell is coupled to another.  <br /></td></tr>
<tr class="separator:a0cbefb568aed4483bc28fc6cc4497914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d82727e2795e5f6c0c22251bd7ee87" id="r_a62d82727e2795e5f6c0c22251bd7ee87"><td class="memItemLeft" align="right" valign="top">std::array&lt; bool, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62d82727e2795e5f6c0c22251bd7ee87">compareMeshes</a> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, 2 &gt; &amp;m1, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, 2 &gt; &amp;m2)</td></tr>
<tr class="memdesc:a62d82727e2795e5f6c0c22251bd7ee87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two meshes for equality.  <br /></td></tr>
<tr class="separator:a62d82727e2795e5f6c0c22251bd7ee87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d91336c91659a3767ddbaf9fa6ec1c" id="r_af1d91336c91659a3767ddbaf9fa6ec1c"><td class="memTemplParams" colspan="2"><a id="af1d91336c91659a3767ddbaf9fa6ec1c" name="af1d91336c91659a3767ddbaf9fa6ec1c"></a>
template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:af1d91336c91659a3767ddbaf9fa6ec1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>kernel_computeCellCentreAoS</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, 2 &gt; &amp;m, const <a class="el" href="#aaebf89314ef9893bfb577bc1551f8f9c">fint</a> cellidx, scalar *const ccentres)</td></tr>
<tr class="memdesc:af1d91336c91659a3767ddbaf9fa6ec1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes cell-centre coordinates for one cell. Assumes an array of structures. <br /></td></tr>
<tr class="separator:af1d91336c91659a3767ddbaf9fa6ec1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a386f658d8ab63d9ef9bdc7cff409c" id="r_ac0a386f658d8ab63d9ef9bdc7cff409c"><td class="memTemplParams" colspan="2"><a id="ac0a386f658d8ab63d9ef9bdc7cff409c" name="ac0a386f658d8ab63d9ef9bdc7cff409c"></a>
template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:ac0a386f658d8ab63d9ef9bdc7cff409c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structfvens_1_1LineConfig.html">LineConfig</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findLines</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, 2 &gt; &amp;m, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> threshold)</td></tr>
<tr class="memdesc:ac0a386f658d8ab63d9ef9bdc7cff409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds lines in the mesh. <br /></td></tr>
<tr class="separator:ac0a386f658d8ab63d9ef9bdc7cff409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3281d4a94c0ad0024b153c2279d79921" id="r_a3281d4a94c0ad0024b153c2279d79921"><td class="memTemplParams" colspan="2"><a id="a3281d4a94c0ad0024b153c2279d79921" name="a3281d4a94c0ad0024b153c2279d79921"></a>
template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a3281d4a94c0ad0024b153c2279d79921"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structfvens_1_1GraphVertices.html">GraphVertices</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createLinePointGraphVertices</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, 2 &gt; &amp;m, const <a class="el" href="structfvens_1_1LineConfig.html">LineConfig</a> &amp;lc)</td></tr>
<tr class="memdesc:a3281d4a94c0ad0024b153c2279d79921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the list of line/point vertices from the mesh and its line configuration. <br /></td></tr>
<tr class="separator:a3281d4a94c0ad0024b153c2279d79921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d87ad7275120d5fb8ca993d4d08c32" id="r_a92d87ad7275120d5fb8ca993d4d08c32"><td class="memTemplParams" colspan="2"><a id="a92d87ad7275120d5fb8ca993d4d08c32" name="a92d87ad7275120d5fb8ca993d4d08c32"></a>
template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a92d87ad7275120d5fb8ca993d4d08c32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createLinePointGraph</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, 2 &gt; &amp;m, const <a class="el" href="structfvens_1_1GraphVertices.html">GraphVertices</a> &amp;gv, Mat *const G)</td></tr>
<tr class="memdesc:a92d87ad7275120d5fb8ca993d4d08c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a graph in which vertices represent lines and points (which are not in lines) in the mesh. <br /></td></tr>
<tr class="separator:a92d87ad7275120d5fb8ca993d4d08c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01dd4999460971acf1da56f73a71df5e" id="r_a01dd4999460971acf1da56f73a71df5e"><td class="memItemLeft" align="right" valign="top"><a id="a01dd4999460971acf1da56f73a71df5e" name="a01dd4999460971acf1da56f73a71df5e"></a>
std::vector&lt; PetscInt &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPetscOrdering</b> (Mat G, const char *const ordering)</td></tr>
<tr class="memdesc:a01dd4999460971acf1da56f73a71df5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses PETSc to get the ordering. <br /></td></tr>
<tr class="separator:a01dd4999460971acf1da56f73a71df5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afa43d0ad674b815e81a03e7f00255f" id="r_a2afa43d0ad674b815e81a03e7f00255f"><td class="memTemplParams" colspan="2"><a id="a2afa43d0ad674b815e81a03e7f00255f" name="a2afa43d0ad674b815e81a03e7f00255f"></a>
template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a2afa43d0ad674b815e81a03e7f00255f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="#aaebf89314ef9893bfb577bc1551f8f9c">fint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getHybridLineOrdering</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, 2 &gt; &amp;m, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> threshold, const char *const ordering)</td></tr>
<tr class="memdesc:a2afa43d0ad674b815e81a03e7f00255f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cell ordering from the graph of lines and points. <br /></td></tr>
<tr class="separator:a2afa43d0ad674b815e81a03e7f00255f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f20b2ca692b4786879b960c2ee4538" id="r_a79f20b2ca692b4786879b960c2ee4538"><td class="memTemplParams" colspan="2">template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a79f20b2ca692b4786879b960c2ee4538"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a79f20b2ca692b4786879b960c2ee4538">lineReorder</a> (<a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, 2 &gt; &amp;m, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> threshold)</td></tr>
<tr class="memdesc:a79f20b2ca692b4786879b960c2ee4538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an ordering where lines of strong coupling are identified and ordered consecutively.  <br /></td></tr>
<tr class="separator:a79f20b2ca692b4786879b960c2ee4538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17baf16252ebdf913380841016c6adda" id="r_a17baf16252ebdf913380841016c6adda"><td class="memTemplParams" colspan="2">template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a17baf16252ebdf913380841016c6adda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a17baf16252ebdf913380841016c6adda">hybridLineReorder</a> (<a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, 2 &gt; &amp;m, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> threshold, const char *const ordering)</td></tr>
<tr class="memdesc:a17baf16252ebdf913380841016c6adda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orders the mesh cells according to a hybrid of line ordering and some other specified ordering.  <br /></td></tr>
<tr class="separator:a17baf16252ebdf913380841016c6adda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e865802f1e8cd84f735d697a9adea1e" id="r_a8e865802f1e8cd84f735d697a9adea1e"><td class="memTemplParams" colspan="2"><a id="a8e865802f1e8cd84f735d697a9adea1e" name="a8e865802f1e8cd84f735d697a9adea1e"></a>
template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a8e865802f1e8cd84f735d697a9adea1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structfvens_1_1LocalAnisotropies.html">LocalAnisotropies</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeWeights</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, 2 &gt; &amp;m)</td></tr>
<tr class="memdesc:a8e865802f1e8cd84f735d697a9adea1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the edge weights about each cell, ordered by decreasing weight. <br /></td></tr>
<tr class="separator:a8e865802f1e8cd84f735d697a9adea1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97571fa35cee32bc6a3bc93a1b0bb2c5" id="r_a97571fa35cee32bc6a3bc93a1b0bb2c5"><td class="memTemplParams" colspan="2"><a id="a97571fa35cee32bc6a3bc93a1b0bb2c5" name="a97571fa35cee32bc6a3bc93a1b0bb2c5"></a>
template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a97571fa35cee32bc6a3bc93a1b0bb2c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createLinePointGraph</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, 2 &gt; &amp;m, const <a class="el" href="structfvens_1_1GraphVertices.html">GraphVertices</a> &amp;gv, Mat *const G)</td></tr>
<tr class="separator:a97571fa35cee32bc6a3bc93a1b0bb2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e49aa4cfea66d624965a6f8a178de6a" id="r_a6e49aa4cfea66d624965a6f8a178de6a"><td class="memItemLeft" align="right" valign="top"><a id="a6e49aa4cfea66d624965a6f8a178de6a" name="a6e49aa4cfea66d624965a6f8a178de6a"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>lineReorder</b> (<a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, 2 &gt; &amp;m, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> threshold)</td></tr>
<tr class="separator:a6e49aa4cfea66d624965a6f8a178de6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32253d6bd925bb745603ab976bdcc839" id="r_a32253d6bd925bb745603ab976bdcc839"><td class="memItemLeft" align="right" valign="top"><a id="a32253d6bd925bb745603ab976bdcc839" name="a32253d6bd925bb745603ab976bdcc839"></a>
template std::vector&lt; <a class="el" href="#aaebf89314ef9893bfb577bc1551f8f9c">fint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getHybridLineOrdering</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, 2 &gt; &amp;m, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> threshold, const char *const ordering)</td></tr>
<tr class="separator:a32253d6bd925bb745603ab976bdcc839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af643ea91e06d3abdf296e3e2bcc18afa" id="r_af643ea91e06d3abdf296e3e2bcc18afa"><td class="memItemLeft" align="right" valign="top"><a id="af643ea91e06d3abdf296e3e2bcc18afa" name="af643ea91e06d3abdf296e3e2bcc18afa"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>hybridLineReorder</b> (<a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, 2 &gt; &amp;m, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> threshold, const char *const ordering)</td></tr>
<tr class="separator:af643ea91e06d3abdf296e3e2bcc18afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff434fb6c97868e0af8715f3811bf08e" id="r_aff434fb6c97868e0af8715f3811bf08e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfvens_1_1ListOfArrays.html">ListOfArrays</a>&lt; <a class="el" href="#aaebf89314ef9893bfb577bc1551f8f9c">fint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff434fb6c97868e0af8715f3811bf08e">getCellAdjLists</a> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;m)</td></tr>
<tr class="memdesc:aff434fb6c97868e0af8715f3811bf08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the adjacency lists of the graph respresented by cells of the mesh.  <br /></td></tr>
<tr class="separator:aff434fb6c97868e0af8715f3811bf08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f717f1c2f1915faf8292763d0f59fe" id="r_a23f717f1c2f1915faf8292763d0f59fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfvens_1_1MeshData.html">MeshData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23f717f1c2f1915faf8292763d0f59fe">readMesh</a> (const std::string mfile)</td></tr>
<tr class="memdesc:a23f717f1c2f1915faf8292763d0f59fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a mesh from a file.  <br /></td></tr>
<tr class="separator:a23f717f1c2f1915faf8292763d0f59fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252eb1b3e765cbc124c43f0680858c85" id="r_a252eb1b3e765cbc124c43f0680858c85"><td class="memTemplParams" colspan="2">template&lt;typename scalar, int ndim, bool secondOrderRequested&gt; </td></tr>
<tr class="memitem:a252eb1b3e765cbc124c43f0680858c85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a252eb1b3e765cbc124c43f0680858c85">getPrimitive2StatesAndGradients</a> (const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; scalar &gt; &amp;physics, const scalar *const ucl, const scalar *const ucr, const scalar *const gradl, const scalar *const gradr, scalar *const uctl, scalar *const uctr, scalar *const gradtl, scalar *const gradtr)</td></tr>
<tr class="memdesc:a252eb1b3e765cbc124c43f0680858c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes primitive-2 variables and temperature grad from conserved variables and primitive grads.  <br /></td></tr>
<tr class="separator:a252eb1b3e765cbc124c43f0680858c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3009dae36597fd895ac71d99adb7f1" id="r_afa3009dae36597fd895ac71d99adb7f1"><td class="memTemplParams" colspan="2">template&lt;typename scalar, int ndim, int nvars, bool constVisc&gt; </td></tr>
<tr class="memitem:afa3009dae36597fd895ac71d99adb7f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afa3009dae36597fd895ac71d99adb7f1">computeViscousFlux</a> (const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; scalar &gt; &amp;physics, const scalar *const n, const scalar grad[ndim][nvars], const scalar *const ul, const scalar *const ur, scalar *const __restrict vflux)</td></tr>
<tr class="memdesc:afa3009dae36597fd895ac71d99adb7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes viscous flux across a face at one point.  <br /></td></tr>
<tr class="separator:afa3009dae36597fd895ac71d99adb7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48049d5eef41436341319cb2d523b0f8" id="r_a48049d5eef41436341319cb2d523b0f8"><td class="memTemplParams" colspan="2">template&lt;typename scalar, int ndim, int nvars, bool constVisc&gt; </td></tr>
<tr class="memitem:a48049d5eef41436341319cb2d523b0f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a48049d5eef41436341319cb2d523b0f8">computeViscousFluxJacobian</a> (const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; scalar &gt; &amp;jphysics, const scalar *const n, const scalar *const ul, const scalar *const ur, const scalar grad[ndim][nvars], const scalar dgradl[ndim][nvars][nvars], const scalar dgradr[ndim][nvars][nvars], scalar *const __restrict dvfi, scalar *const __restrict dvfj)</td></tr>
<tr class="memdesc:a48049d5eef41436341319cb2d523b0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobians of the viscous flux w.r.t. left and right cell-centered states.  <br /></td></tr>
<tr class="separator:a48049d5eef41436341319cb2d523b0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d9b50d7328e453bbe300805c1b0582" id="r_a24d9b50d7328e453bbe300805c1b0582"><td class="memItemLeft" align="right" valign="top"><a id="a24d9b50d7328e453bbe300805c1b0582" name="a24d9b50d7328e453bbe300805c1b0582"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>getPrimitive2StatesAndGradients&lt; freal, NDIM, true &gt;</b> (const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; &amp;physics, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const ucl, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const ucr, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const gradl, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const gradr, <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const uctl, <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const uctr, <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const gradtl, <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const gradtr)</td></tr>
<tr class="separator:a24d9b50d7328e453bbe300805c1b0582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300bd369f3b9726c5de44d146ada583f" id="r_a300bd369f3b9726c5de44d146ada583f"><td class="memItemLeft" align="right" valign="top"><a id="a300bd369f3b9726c5de44d146ada583f" name="a300bd369f3b9726c5de44d146ada583f"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>getPrimitive2StatesAndGradients&lt; freal, NDIM, false &gt;</b> (const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; &amp;physics, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const ucl, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const ucr, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const gradl, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const gradr, <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const uctl, <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const uctr, <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const gradtl, <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const gradtr)</td></tr>
<tr class="separator:a300bd369f3b9726c5de44d146ada583f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabe1972f34e81121ad2c4f49d9d9108" id="r_aaabe1972f34e81121ad2c4f49d9d9108"><td class="memItemLeft" align="right" valign="top"><a id="aaabe1972f34e81121ad2c4f49d9d9108" name="aaabe1972f34e81121ad2c4f49d9d9108"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>computeViscousFlux&lt; freal, NDIM, NVARS, true &gt;</b> (const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; &amp;physics, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const n, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> grad[<a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a>][<a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a>], const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const ul, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const ur, <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const __restrict vflux)</td></tr>
<tr class="separator:aaabe1972f34e81121ad2c4f49d9d9108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fd92b9cc8d31b084c146faca48e822" id="r_a97fd92b9cc8d31b084c146faca48e822"><td class="memItemLeft" align="right" valign="top"><a id="a97fd92b9cc8d31b084c146faca48e822" name="a97fd92b9cc8d31b084c146faca48e822"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>computeViscousFlux&lt; freal, NDIM, NVARS, false &gt;</b> (const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; &amp;physics, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const n, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> grad[<a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a>][<a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a>], const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const ul, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const ur, <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const __restrict vflux)</td></tr>
<tr class="separator:a97fd92b9cc8d31b084c146faca48e822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dc6485d45e354b268d732925ee6297" id="r_a54dc6485d45e354b268d732925ee6297"><td class="memItemLeft" align="right" valign="top"><a id="a54dc6485d45e354b268d732925ee6297" name="a54dc6485d45e354b268d732925ee6297"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>computeViscousFluxJacobian&lt; freal, NDIM, NVARS, true &gt;</b> (const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; &amp;jphy, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const n, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const ul, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const ur, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> grad[<a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a>][<a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a>], const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> dgradl[<a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a>][<a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a>][<a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a>], const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> dgradr[<a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a>][<a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a>][<a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a>], <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const __restrict dvfi, <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const __restrict dvfj)</td></tr>
<tr class="separator:a54dc6485d45e354b268d732925ee6297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5abe591e6282b40dbc90c1660e7add" id="r_a1d5abe591e6282b40dbc90c1660e7add"><td class="memItemLeft" align="right" valign="top"><a id="a1d5abe591e6282b40dbc90c1660e7add" name="a1d5abe591e6282b40dbc90c1660e7add"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>computeViscousFluxJacobian&lt; freal, NDIM, NVARS, false &gt;</b> (const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; &amp;jphy, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const n, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const ul, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const ur, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> grad[<a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a>][<a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a>], const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> dgradl[<a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a>][<a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a>][<a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a>], const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> dgradr[<a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a>][<a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a>][<a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a>], <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const __restrict dvfi, <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const __restrict dvfj)</td></tr>
<tr class="separator:a1d5abe591e6282b40dbc90c1660e7add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce28ba01c56cbfb14ea947b344b954d" id="r_a0ce28ba01c56cbfb14ea947b344b954d"><td class="memTemplParams" colspan="2">template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a0ce28ba01c56cbfb14ea947b344b954d"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; int, const <a class="el" href="classfvens_1_1FlowBC.html">FlowBC</a>&lt; scalar &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ce28ba01c56cbfb14ea947b344b954d">create_const_flowBCs</a> (const std::vector&lt; <a class="el" href="structfvens_1_1FlowBCConfig.html">FlowBCConfig</a> &gt; &amp;conf, const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; scalar &gt; &amp;physics, const std::array&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a> &gt; &amp;uinf)</td></tr>
<tr class="memdesc:a0ce28ba01c56cbfb14ea947b344b954d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a set of pointers to immutable boundary condition objects, possibly of different types.  <br /></td></tr>
<tr class="separator:a0ce28ba01c56cbfb14ea947b344b954d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a23740640ab28c7d75c4d4204541ee" id="r_a46a23740640ab28c7d75c4d4204541ee"><td class="memItemLeft" align="right" valign="top"><a id="a46a23740640ab28c7d75c4d4204541ee" name="a46a23740640ab28c7d75c4d4204541ee"></a>
template std::map&lt; int, const <a class="el" href="classfvens_1_1FlowBC.html">FlowBC</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>create_const_flowBCs</b> (const std::vector&lt; <a class="el" href="structfvens_1_1FlowBCConfig.html">FlowBCConfig</a> &gt; &amp;conf, const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; &amp;physics, const std::array&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a> &gt; &amp;uinf)</td></tr>
<tr class="separator:a46a23740640ab28c7d75c4d4204541ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c8bb9667214507dc15f5ccb55ca943" id="r_af6c8bb9667214507dc15f5ccb55ca943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6c8bb9667214507dc15f5ccb55ca943">writeScalarsVectorToVtu_CellData</a> (std::string fname, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;m, const <a class="el" href="classfvens_1_1amat_1_1Array2d.html">amat::Array2d</a>&lt; double &gt; &amp;x, std::string scaname[], const <a class="el" href="classfvens_1_1amat_1_1Array2d.html">amat::Array2d</a>&lt; double &gt; &amp;y, std::string vecname)</td></tr>
<tr class="memdesc:af6c8bb9667214507dc15f5ccb55ca943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes multiple scalar data sets and one vector data set, all cell-centered data, to a file in VTU format.  <br /></td></tr>
<tr class="separator:af6c8bb9667214507dc15f5ccb55ca943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283d11c168af57d6227eb7e89561727b" id="r_a283d11c168af57d6227eb7e89561727b"><td class="memItemLeft" align="right" valign="top"><a id="a283d11c168af57d6227eb7e89561727b" name="a283d11c168af57d6227eb7e89561727b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>writeScalarsVectorToVtu_PointData</b> (std::string fname, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;m, const <a class="el" href="classfvens_1_1amat_1_1Array2d.html">amat::Array2d</a>&lt; double &gt; &amp;x, std::string scaname[], const <a class="el" href="classfvens_1_1amat_1_1Array2d.html">amat::Array2d</a>&lt; double &gt; &amp;y, std::string vecname)</td></tr>
<tr class="memdesc:a283d11c168af57d6227eb7e89561727b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes nodal data to VTU file. <br /></td></tr>
<tr class="separator:a283d11c168af57d6227eb7e89561727b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68442829966f7546c0947f021eb0c998" id="r_a68442829966f7546c0947f021eb0c998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68442829966f7546c0947f021eb0c998">writeMeshToVtu</a> (std::string fname, const <a class="el" href="classfvens_1_1UMesh.html">fvens::UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;m)</td></tr>
<tr class="memdesc:a68442829966f7546c0947f021eb0c998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a hybrid mesh in VTU format.  <br /></td></tr>
<tr class="separator:a68442829966f7546c0947f021eb0c998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8d3555fc03b3dab79b623ddabe0e3f" id="r_a9e8d3555fc03b3dab79b623ddabe0e3f"><td class="memItemLeft" align="right" valign="top"><a id="a9e8d3555fc03b3dab79b623ddabe0e3f" name="a9e8d3555fc03b3dab79b623ddabe0e3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>writeConvergenceHistoryHeader</b> (std::ostream &amp;outf)</td></tr>
<tr class="memdesc:a9e8d3555fc03b3dab79b623ddabe0e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out the column of headers of convergence history to a file. <br /></td></tr>
<tr class="separator:a9e8d3555fc03b3dab79b623ddabe0e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed701c020ec801cee884364048425b70" id="r_aed701c020ec801cee884364048425b70"><td class="memItemLeft" align="right" valign="top"><a id="aed701c020ec801cee884364048425b70" name="aed701c020ec801cee884364048425b70"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>writeStepToConvergenceHistory</b> (const <a class="el" href="structfvens_1_1SteadyStepMonitor.html">SteadyStepMonitor</a> step, std::ostream &amp;outf)</td></tr>
<tr class="memdesc:aed701c020ec801cee884364048425b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints monitor data for one step of convergence history to a file. <br /></td></tr>
<tr class="separator:aed701c020ec801cee884364048425b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44706444b9335074c9fcc1949e83a9af" id="r_a44706444b9335074c9fcc1949e83a9af"><td class="memTemplParams" colspan="2"><a id="a44706444b9335074c9fcc1949e83a9af" name="a44706444b9335074c9fcc1949e83a9af"></a>
template&lt;int nvars&gt; </td></tr>
<tr class="memitem:a44706444b9335074c9fcc1949e83a9af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scalar_postprocess_point</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const Vec uvec, <a class="el" href="classfvens_1_1amat_1_1Array2d.html">amat::Array2d</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; &amp;up)</td></tr>
<tr class="separator:a44706444b9335074c9fcc1949e83a9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6e04a74826107715564cb9801e95fd" id="r_aac6e04a74826107715564cb9801e95fd"><td class="memItemLeft" align="right" valign="top"><a id="aac6e04a74826107715564cb9801e95fd" name="aac6e04a74826107715564cb9801e95fd"></a>
template <a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>scalar_postprocess_point&lt; 1 &gt;</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const Vec uvec, <a class="el" href="classfvens_1_1amat_1_1Array2d.html">amat::Array2d</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; &amp;up)</td></tr>
<tr class="separator:aac6e04a74826107715564cb9801e95fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7dcb4eb2bf8fe37b8ea91b48b621bc2" id="r_af7dcb4eb2bf8fe37b8ea91b48b621bc2"><td class="memItemLeft" align="right" valign="top"><a id="af7dcb4eb2bf8fe37b8ea91b48b621bc2" name="af7dcb4eb2bf8fe37b8ea91b48b621bc2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af7dcb4eb2bf8fe37b8ea91b48b621bc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getvalue</b> (const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> x)</td></tr>
<tr class="separator:af7dcb4eb2bf8fe37b8ea91b48b621bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504c92c9fd48d95c301bbb447e128051" id="r_a504c92c9fd48d95c301bbb447e128051"><td class="memItemLeft" align="right" valign="top"><a id="a504c92c9fd48d95c301bbb447e128051" name="a504c92c9fd48d95c301bbb447e128051"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>open_file_toRead</b> (const std::string file, std::ifstream &amp;fin)</td></tr>
<tr class="memdesc:a504c92c9fd48d95c301bbb447e128051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a file for reading but aborts in case of an error. <br /></td></tr>
<tr class="separator:a504c92c9fd48d95c301bbb447e128051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26396d733e1da333b0fe284e5ae2eed" id="r_ad26396d733e1da333b0fe284e5ae2eed"><td class="memItemLeft" align="right" valign="top"><a id="ad26396d733e1da333b0fe284e5ae2eed" name="ad26396d733e1da333b0fe284e5ae2eed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>open_file_toWrite</b> (const std::string file, std::ofstream &amp;fout)</td></tr>
<tr class="memdesc:ad26396d733e1da333b0fe284e5ae2eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a file for writing but throws in case of an error. <br /></td></tr>
<tr class="separator:ad26396d733e1da333b0fe284e5ae2eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520c29030bbab3242026a7c771b80d95" id="r_a520c29030bbab3242026a7c771b80d95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a520c29030bbab3242026a7c771b80d95">fvens_throw</a> (const int ierr, const std::string str)</td></tr>
<tr class="memdesc:a520c29030bbab3242026a7c771b80d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an error from an error code.  <br /></td></tr>
<tr class="separator:a520c29030bbab3242026a7c771b80d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06634f6cec73c21ac8394b85c86167d4" id="r_a06634f6cec73c21ac8394b85c86167d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06634f6cec73c21ac8394b85c86167d4">mpi_throw</a> (const int ierr, const std::string str)</td></tr>
<tr class="memdesc:a06634f6cec73c21ac8394b85c86167d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an error from an error code related to MPI.  <br /></td></tr>
<tr class="separator:a06634f6cec73c21ac8394b85c86167d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dd7a233fbbde39f38e87c400f7e9ce" id="r_a68dd7a233fbbde39f38e87c400f7e9ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68dd7a233fbbde39f38e87c400f7e9ce">petsc_throw</a> (const int ierr, const std::string str)</td></tr>
<tr class="memdesc:a68dd7a233fbbde39f38e87c400f7e9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">throw an error from an error code related to petsc  <br /></td></tr>
<tr class="separator:a68dd7a233fbbde39f38e87c400f7e9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aecf6dedc6a55ede8da57fbde92bdfa" id="r_a4aecf6dedc6a55ede8da57fbde92bdfa"><td class="memTemplParams" colspan="2"><a id="a4aecf6dedc6a55ede8da57fbde92bdfa" name="a4aecf6dedc6a55ede8da57fbde92bdfa"></a>
template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a4aecf6dedc6a55ede8da57fbde92bdfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfvens_1_1InviscidFlux.html">InviscidFlux</a>&lt; scalar &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_mutable_inviscidflux</b> (const std::string &amp;type, const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; scalar &gt; *const p)</td></tr>
<tr class="memdesc:a4aecf6dedc6a55ede8da57fbde92bdfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new inviscid numerical flux context. <br /></td></tr>
<tr class="separator:a4aecf6dedc6a55ede8da57fbde92bdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fb49769fd97fcb5cb9c8be45a19c09" id="r_a94fb49769fd97fcb5cb9c8be45a19c09"><td class="memTemplParams" colspan="2"><a id="a94fb49769fd97fcb5cb9c8be45a19c09" name="a94fb49769fd97fcb5cb9c8be45a19c09"></a>
template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a94fb49769fd97fcb5cb9c8be45a19c09"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classfvens_1_1InviscidFlux.html">InviscidFlux</a>&lt; scalar &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_const_inviscidflux</b> (const std::string &amp;type, const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; scalar &gt; *const p)</td></tr>
<tr class="memdesc:a94fb49769fd97fcb5cb9c8be45a19c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new immutable inviscid flux context. <br /></td></tr>
<tr class="separator:a94fb49769fd97fcb5cb9c8be45a19c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7aba4cdc86cead530386182ab64a0c" id="r_acc7aba4cdc86cead530386182ab64a0c"><td class="memItemLeft" align="right" valign="top"><a id="acc7aba4cdc86cead530386182ab64a0c" name="acc7aba4cdc86cead530386182ab64a0c"></a>
template <a class="el" href="classfvens_1_1InviscidFlux.html">InviscidFlux</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>create_mutable_inviscidflux</b> (const std::string &amp;type, const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; *const p)</td></tr>
<tr class="separator:acc7aba4cdc86cead530386182ab64a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376d15703d0320582da905f8d2871e8c" id="r_a376d15703d0320582da905f8d2871e8c"><td class="memItemLeft" align="right" valign="top"><a id="a376d15703d0320582da905f8d2871e8c" name="a376d15703d0320582da905f8d2871e8c"></a>
template const <a class="el" href="classfvens_1_1InviscidFlux.html">InviscidFlux</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>create_const_inviscidflux</b> (const std::string &amp;type, const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; *const p)</td></tr>
<tr class="separator:a376d15703d0320582da905f8d2871e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34bed1b743b6b7fd52c984cd49a4eda" id="r_af34bed1b743b6b7fd52c984cd49a4eda"><td class="memTemplParams" colspan="2">template&lt;typename scalar, int nvars&gt; </td></tr>
<tr class="memitem:af34bed1b743b6b7fd52c984cd49a4eda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfvens_1_1GradientScheme.html">GradientScheme</a>&lt; scalar, nvars &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af34bed1b743b6b7fd52c984cd49a4eda">create_mutable_gradientscheme</a> (const std::string &amp;type, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const scalar *const rc, const scalar *const rcbp)</td></tr>
<tr class="memdesc:af34bed1b743b6b7fd52c984cd49a4eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly-created gradient computation context.  <br /></td></tr>
<tr class="separator:af34bed1b743b6b7fd52c984cd49a4eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748c7114efe2e6252930479473524cb2" id="r_a748c7114efe2e6252930479473524cb2"><td class="memTemplParams" colspan="2">template&lt;typename scalar, int nvars&gt; </td></tr>
<tr class="memitem:a748c7114efe2e6252930479473524cb2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classfvens_1_1GradientScheme.html">GradientScheme</a>&lt; scalar, nvars &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a748c7114efe2e6252930479473524cb2">create_const_gradientscheme</a> (const std::string &amp;type, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const scalar *const rc, const scalar *const rcbp)</td></tr>
<tr class="memdesc:a748c7114efe2e6252930479473524cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly-created immutable gradient computation context.  <br /></td></tr>
<tr class="separator:a748c7114efe2e6252930479473524cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bc1563c5f100d92fc354deb6dfe732" id="r_a77bc1563c5f100d92fc354deb6dfe732"><td class="memItemLeft" align="right" valign="top"><a id="a77bc1563c5f100d92fc354deb6dfe732" name="a77bc1563c5f100d92fc354deb6dfe732"></a>
template <a class="el" href="classfvens_1_1GradientScheme.html">GradientScheme</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>create_mutable_gradientscheme&lt; freal, NVARS &gt;</b> (const std::string &amp;type, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const rc, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const rcbp)</td></tr>
<tr class="separator:a77bc1563c5f100d92fc354deb6dfe732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7748d1093e5d989f8e4a81c83dae4ca1" id="r_a7748d1093e5d989f8e4a81c83dae4ca1"><td class="memItemLeft" align="right" valign="top"><a id="a7748d1093e5d989f8e4a81c83dae4ca1" name="a7748d1093e5d989f8e4a81c83dae4ca1"></a>
template const <a class="el" href="classfvens_1_1GradientScheme.html">GradientScheme</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>create_const_gradientscheme&lt; freal, NVARS &gt;</b> (const std::string &amp;type, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const rc, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const rcbp)</td></tr>
<tr class="separator:a7748d1093e5d989f8e4a81c83dae4ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d9ae00acf61ec2d0268160ede25ddd" id="r_a93d9ae00acf61ec2d0268160ede25ddd"><td class="memItemLeft" align="right" valign="top"><a id="a93d9ae00acf61ec2d0268160ede25ddd" name="a93d9ae00acf61ec2d0268160ede25ddd"></a>
template <a class="el" href="classfvens_1_1GradientScheme.html">GradientScheme</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, 1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>create_mutable_gradientscheme&lt; freal, 1 &gt;</b> (const std::string &amp;type, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const rc, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const rcbp)</td></tr>
<tr class="separator:a93d9ae00acf61ec2d0268160ede25ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65aad2f0011dae2f8bef70bb7e26f20" id="r_ad65aad2f0011dae2f8bef70bb7e26f20"><td class="memItemLeft" align="right" valign="top"><a id="ad65aad2f0011dae2f8bef70bb7e26f20" name="ad65aad2f0011dae2f8bef70bb7e26f20"></a>
template const <a class="el" href="classfvens_1_1GradientScheme.html">GradientScheme</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, 1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>create_const_gradientscheme&lt; freal, 1 &gt;</b> (const std::string &amp;type, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const rc, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const rcbp)</td></tr>
<tr class="separator:ad65aad2f0011dae2f8bef70bb7e26f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af664e21c4eef2a91eca08bd96f67a18f" id="r_af664e21c4eef2a91eca08bd96f67a18f"><td class="memTemplParams" colspan="2">template&lt;typename scalar, int nvars&gt; </td></tr>
<tr class="memitem:af664e21c4eef2a91eca08bd96f67a18f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfvens_1_1SolutionReconstruction.html">SolutionReconstruction</a>&lt; scalar, nvars &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af664e21c4eef2a91eca08bd96f67a18f">create_mutable_reconstruction</a> (const std::string &amp;type, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const scalar *const rc, const scalar *const rcbp, const <a class="el" href="classfvens_1_1amat_1_1Array2d.html">amat::Array2d</a>&lt; scalar &gt; &amp;gr, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> param)</td></tr>
<tr class="memdesc:af664e21c4eef2a91eca08bd96f67a18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a solution reconstruction context.  <br /></td></tr>
<tr class="separator:af664e21c4eef2a91eca08bd96f67a18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ece0b65a3a151f6c95920916a7674e" id="r_a94ece0b65a3a151f6c95920916a7674e"><td class="memTemplParams" colspan="2">template&lt;typename scalar, int nvars&gt; </td></tr>
<tr class="memitem:a94ece0b65a3a151f6c95920916a7674e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classfvens_1_1SolutionReconstruction.html">SolutionReconstruction</a>&lt; scalar, nvars &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a94ece0b65a3a151f6c95920916a7674e">create_const_reconstruction</a> (const std::string &amp;type, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const scalar *const rc, const scalar *const rcbp, const <a class="el" href="classfvens_1_1amat_1_1Array2d.html">amat::Array2d</a>&lt; scalar &gt; &amp;gr, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> param)</td></tr>
<tr class="memdesc:a94ece0b65a3a151f6c95920916a7674e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an immutable solution reconstruction context.  <br /></td></tr>
<tr class="separator:a94ece0b65a3a151f6c95920916a7674e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992f55ef75a30372b1edb719f72fa0f8" id="r_a992f55ef75a30372b1edb719f72fa0f8"><td class="memItemLeft" align="right" valign="top"><a id="a992f55ef75a30372b1edb719f72fa0f8" name="a992f55ef75a30372b1edb719f72fa0f8"></a>
template <a class="el" href="classfvens_1_1SolutionReconstruction.html">SolutionReconstruction</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>create_mutable_reconstruction</b> (const std::string &amp;type, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const rc, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const rcbp, const <a class="el" href="classfvens_1_1amat_1_1Array2d.html">amat::Array2d</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; &amp;gr, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> param)</td></tr>
<tr class="separator:a992f55ef75a30372b1edb719f72fa0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1afd8d35436c903f4ea6b00ff9880c7" id="r_ae1afd8d35436c903f4ea6b00ff9880c7"><td class="memItemLeft" align="right" valign="top"><a id="ae1afd8d35436c903f4ea6b00ff9880c7" name="ae1afd8d35436c903f4ea6b00ff9880c7"></a>
template const <a class="el" href="classfvens_1_1SolutionReconstruction.html">SolutionReconstruction</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>create_const_reconstruction</b> (const std::string &amp;type, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const rc, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const rcbp, const <a class="el" href="classfvens_1_1amat_1_1Array2d.html">amat::Array2d</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; &amp;gr, const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> param)</td></tr>
<tr class="separator:ae1afd8d35436c903f4ea6b00ff9880c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5cbc8295a2dd53a534d963a006e9a9" id="r_a1c5cbc8295a2dd53a534d963a006e9a9"><td class="memTemplParams" colspan="2">template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a1c5cbc8295a2dd53a534d963a006e9a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfvens_1_1FlowFV__base.html">FlowFV_base</a>&lt; scalar &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1c5cbc8295a2dd53a534d963a006e9a9">create_mutable_flowSpatialDiscretization</a> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const <a class="el" href="structfvens_1_1FlowPhysicsConfig.html">FlowPhysicsConfig</a> &amp;pconf, const <a class="el" href="structfvens_1_1FlowNumericsConfig.html">FlowNumericsConfig</a> &amp;nconf)</td></tr>
<tr class="memdesc:a1c5cbc8295a2dd53a534d963a006e9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the appropriate flow solver class.  <br /></td></tr>
<tr class="separator:a1c5cbc8295a2dd53a534d963a006e9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4906c48ce25b4fa8cb3a7d8e46cb1fe" id="r_ab4906c48ce25b4fa8cb3a7d8e46cb1fe"><td class="memTemplParams" colspan="2">template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:ab4906c48ce25b4fa8cb3a7d8e46cb1fe"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classfvens_1_1FlowFV__base.html">FlowFV_base</a>&lt; scalar &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4906c48ce25b4fa8cb3a7d8e46cb1fe">create_const_flowSpatialDiscretization</a> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const <a class="el" href="structfvens_1_1FlowPhysicsConfig.html">FlowPhysicsConfig</a> &amp;pconf, const <a class="el" href="structfvens_1_1FlowNumericsConfig.html">FlowNumericsConfig</a> &amp;nconf)</td></tr>
<tr class="memdesc:ab4906c48ce25b4fa8cb3a7d8e46cb1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an immutable spatial discretization for slow problems.  <br /></td></tr>
<tr class="separator:ab4906c48ce25b4fa8cb3a7d8e46cb1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a7ccf500c69ab712063e4985577a1a" id="r_ac3a7ccf500c69ab712063e4985577a1a"><td class="memItemLeft" align="right" valign="top"><a id="ac3a7ccf500c69ab712063e4985577a1a" name="ac3a7ccf500c69ab712063e4985577a1a"></a>
template const <a class="el" href="classfvens_1_1FlowFV__base.html">FlowFV_base</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>create_const_flowSpatialDiscretization&lt; freal &gt;</b> (const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const m, const <a class="el" href="structfvens_1_1FlowPhysicsConfig.html">FlowPhysicsConfig</a> &amp;pconf, const <a class="el" href="structfvens_1_1FlowNumericsConfig.html">FlowNumericsConfig</a> &amp;nconf)</td></tr>
<tr class="separator:ac3a7ccf500c69ab712063e4985577a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361ec66f90c10e9d0695f1f04b279f92" id="r_a361ec66f90c10e9d0695f1f04b279f92"><td class="memTemplParams" colspan="2"><a id="a361ec66f90c10e9d0695f1f04b279f92" name="a361ec66f90c10e9d0695f1f04b279f92"></a>
template&lt;int nvars&gt; </td></tr>
<tr class="memitem:a361ec66f90c10e9d0695f1f04b279f92"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classfvens_1_1NonlinearUpdate.html">NonlinearUpdate</a>&lt; nvars &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_const_nonlinearUpdateScheme</b> (const <a class="el" href="structfvens_1_1FlowParserOptions.html">FlowParserOptions</a> &amp;opts)</td></tr>
<tr class="memdesc:a361ec66f90c10e9d0695f1f04b279f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a nonlinear update (under-relaxation) scheme. <br /></td></tr>
<tr class="separator:a361ec66f90c10e9d0695f1f04b279f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38cf3bcff3cb0a3892a31eada83eb94" id="r_ab38cf3bcff3cb0a3892a31eada83eb94"><td class="memItemLeft" align="right" valign="top"><a id="ab38cf3bcff3cb0a3892a31eada83eb94" name="ab38cf3bcff3cb0a3892a31eada83eb94"></a>
template const <a class="el" href="classfvens_1_1NonlinearUpdate.html">NonlinearUpdate</a>&lt; 1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>create_const_nonlinearUpdateScheme</b> (const <a class="el" href="structfvens_1_1FlowParserOptions.html">FlowParserOptions</a> &amp;opts)</td></tr>
<tr class="separator:ab38cf3bcff3cb0a3892a31eada83eb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8f244feb271a9e8849ec717aba50b7" id="r_a5d8f244feb271a9e8849ec717aba50b7"><td class="memItemLeft" align="right" valign="top"><a id="a5d8f244feb271a9e8849ec717aba50b7" name="a5d8f244feb271a9e8849ec717aba50b7"></a>
po::variables_map&#160;</td><td class="memItemRight" valign="bottom"><b>parse_cmd_options</b> (const int argc, const char *const argv[], po::options_description &amp;desc)</td></tr>
<tr class="separator:a5d8f244feb271a9e8849ec717aba50b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8073edb2c5d2101b8525a8aaa38b6a" id="r_aad8073edb2c5d2101b8525a8aaa38b6a"><td class="memItemLeft" align="right" valign="top"><a id="aad8073edb2c5d2101b8525a8aaa38b6a" name="aad8073edb2c5d2101b8525a8aaa38b6a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parsePetscCmd_isDefined</b> (const std::string optionname)</td></tr>
<tr class="memdesc:aad8073edb2c5d2101b8525a8aaa38b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a command line option has been passed irrespective of any argument values. <br /></td></tr>
<tr class="separator:aad8073edb2c5d2101b8525a8aaa38b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfd8414d44b131a34b5185582487090" id="r_a4dfd8414d44b131a34b5185582487090"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dfd8414d44b131a34b5185582487090">parsePetscCmd_int</a> (const std::string optionname)</td></tr>
<tr class="memdesc:a4dfd8414d44b131a34b5185582487090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an integer corresponding to the argument from the default PETSc options database.  <br /></td></tr>
<tr class="separator:a4dfd8414d44b131a34b5185582487090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe08cf3c6fd44941b3023293365128b1" id="r_abe08cf3c6fd44941b3023293365128b1"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe08cf3c6fd44941b3023293365128b1">parseOptionalPetscCmd_real</a> (const std::string optionname, const PetscReal defval)</td></tr>
<tr class="memdesc:abe08cf3c6fd44941b3023293365128b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optionally extracts a real corresponding to the argument from the default PETSc options database.  <br /></td></tr>
<tr class="separator:abe08cf3c6fd44941b3023293365128b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9334ba9120098d4c9902d554f0841c3" id="r_aa9334ba9120098d4c9902d554f0841c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9334ba9120098d4c9902d554f0841c3">parsePetscCmd_bool</a> (const std::string optionname)</td></tr>
<tr class="memdesc:aa9334ba9120098d4c9902d554f0841c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a boolean corresponding to the argument from the default PETSc options database.  <br /></td></tr>
<tr class="separator:aa9334ba9120098d4c9902d554f0841c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d02934e9fc273ed7d5092c85413abd" id="r_a38d02934e9fc273ed7d5092c85413abd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38d02934e9fc273ed7d5092c85413abd">parseOptionalPetscCmd_bool</a> (const std::string optionname)</td></tr>
<tr class="memdesc:a38d02934e9fc273ed7d5092c85413abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a boolean corresponding to an optional argument from the default PETSc options database.  <br /></td></tr>
<tr class="separator:a38d02934e9fc273ed7d5092c85413abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5604f61952376355ab5a774e6d8df38f" id="r_a5604f61952376355ab5a774e6d8df38f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5604f61952376355ab5a774e6d8df38f">parsePetscCmd_string</a> (const std::string optionname, const size_t len)</td></tr>
<tr class="memdesc:a5604f61952376355ab5a774e6d8df38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a string corresponding to the argument from the default PETSc options database.  <br /></td></tr>
<tr class="separator:a5604f61952376355ab5a774e6d8df38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40941319ec81093b1e86aaefe3f3962b" id="r_a40941319ec81093b1e86aaefe3f3962b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40941319ec81093b1e86aaefe3f3962b">parsePetscCmd_intArray</a> (const std::string optionname, const int maxlen)</td></tr>
<tr class="memdesc:a40941319ec81093b1e86aaefe3f3962b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the arguments of an int array option from the default PETSc options database.  <br /></td></tr>
<tr class="separator:a40941319ec81093b1e86aaefe3f3962b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb7b42d9f36998258171ee4aa4e0220" id="r_a1cb7b42d9f36998258171ee4aa4e0220"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cb7b42d9f36998258171ee4aa4e0220">parseOptionalPetscCmd_intArray</a> (const std::string optionname, const int maxlen)</td></tr>
<tr class="memdesc:a1cb7b42d9f36998258171ee4aa4e0220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the arguments of an int array option from the default PETSc options database.  <br /></td></tr>
<tr class="separator:a1cb7b42d9f36998258171ee4aa4e0220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa2dc00e53fdc96ba6d61f6f3e742c0" id="r_a7fa2dc00e53fdc96ba6d61f6f3e742c0"><td class="memItemLeft" align="right" valign="top"><a id="a7fa2dc00e53fdc96ba6d61f6f3e742c0" name="a7fa2dc00e53fdc96ba6d61f6f3e742c0"></a>
boost::program_options::variables_map&#160;</td><td class="memItemRight" valign="bottom"><b>parse_cmd_options</b> (const int argc, const char *const argv[], boost::program_options::options_description &amp;desc)</td></tr>
<tr class="memdesc:a7fa2dc00e53fdc96ba6d61f6f3e742c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses command line parameters into a map. <br /></td></tr>
<tr class="separator:a7fa2dc00e53fdc96ba6d61f6f3e742c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fd3df42a189c16a0fd8f059ca2af97" id="r_a85fd3df42a189c16a0fd8f059ca2af97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85fd3df42a189c16a0fd8f059ca2af97">constructMeshFlow</a> (const <a class="el" href="structfvens_1_1FlowParserOptions.html">FlowParserOptions</a> &amp;opts, const std::string mesh_suffix)</td></tr>
<tr class="memdesc:a85fd3df42a189c16a0fd8f059ca2af97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a mesh for use in a fluid simulation.  <br /></td></tr>
<tr class="separator:a85fd3df42a189c16a0fd8f059ca2af97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198351b432103f4793a0a6c0c318590a" id="r_a198351b432103f4793a0a6c0c318590a"><td class="memItemLeft" align="right" valign="top"><a id="a198351b432103f4793a0a6c0c318590a" name="a198351b432103f4793a0a6c0c318590a"></a>
const <a class="el" href="classfvens_1_1FlowFV__base.html">FlowFV_base</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>createFlowSpatial</b> (const <a class="el" href="structfvens_1_1FlowParserOptions.html">FlowParserOptions</a> &amp;opts, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;m)</td></tr>
<tr class="memdesc:a198351b432103f4793a0a6c0c318590a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a spatial discretization context for the flow problem. <br /></td></tr>
<tr class="separator:a198351b432103f4793a0a6c0c318590a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57fac984b13e9dd7072123ff707ef60" id="r_ae57fac984b13e9dd7072123ff707ef60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae57fac984b13e9dd7072123ff707ef60">initializeSystemVector</a> (const <a class="el" href="structfvens_1_1FlowParserOptions.html">FlowParserOptions</a> &amp;opts, const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;m, Vec *const u)</td></tr>
<tr class="separator:ae57fac984b13e9dd7072123ff707ef60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e01eb35a4982f438b7908a4ebd82e1f" id="r_a5e01eb35a4982f438b7908a4ebd82e1f"><td class="memItemLeft" align="right" valign="top"><a id="a5e01eb35a4982f438b7908a4ebd82e1f" name="a5e01eb35a4982f438b7908a4ebd82e1f"></a>
<a class="el" href="structfvens_1_1FlowParserOptions.html">FlowParserOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parse_flow_controlfile</b> (const int argc, const char *const argv[], const po::variables_map cmdvars)</td></tr>
<tr class="separator:a5e01eb35a4982f438b7908a4ebd82e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ccdf1e6c622714922018b4845eedd0" id="r_a81ccdf1e6c622714922018b4845eedd0"><td class="memItemLeft" align="right" valign="top"><a id="a81ccdf1e6c622714922018b4845eedd0" name="a81ccdf1e6c622714922018b4845eedd0"></a>
<a class="el" href="structfvens_1_1FlowPhysicsConfig.html">FlowPhysicsConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><b>extract_spatial_physics_config</b> (const <a class="el" href="structfvens_1_1FlowParserOptions.html">FlowParserOptions</a> &amp;opts)</td></tr>
<tr class="memdesc:a81ccdf1e6c622714922018b4845eedd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the spatial physics configuration from the parsed control file data. <br /></td></tr>
<tr class="separator:a81ccdf1e6c622714922018b4845eedd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e1a08b2e0612e9a84396b89a536dec" id="r_ae7e1a08b2e0612e9a84396b89a536dec"><td class="memItemLeft" align="right" valign="top"><a id="ae7e1a08b2e0612e9a84396b89a536dec" name="ae7e1a08b2e0612e9a84396b89a536dec"></a>
<a class="el" href="structfvens_1_1FlowNumericsConfig.html">FlowNumericsConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><b>extract_spatial_numerics_config</b> (const <a class="el" href="structfvens_1_1FlowParserOptions.html">FlowParserOptions</a> &amp;opts)</td></tr>
<tr class="memdesc:ae7e1a08b2e0612e9a84396b89a536dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the spatial discretization's settings from the parsed control file data. <br /></td></tr>
<tr class="separator:ae7e1a08b2e0612e9a84396b89a536dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4217115d355c835837c0f786c170ca69" id="r_a4217115d355c835837c0f786c170ca69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfvens_1_1FlowNumericsConfig.html">FlowNumericsConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4217115d355c835837c0f786c170ca69">firstorder_spatial_numerics_config</a> (const <a class="el" href="structfvens_1_1FlowParserOptions.html">FlowParserOptions</a> &amp;opts)</td></tr>
<tr class="separator:a4217115d355c835837c0f786c170ca69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845c27cec3521110457cad602b519017" id="r_a845c27cec3521110457cad602b519017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfvens_1_1FlowParserOptions.html">FlowParserOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a845c27cec3521110457cad602b519017">parse_flow_controlfile</a> (const int argc, const char *const argv[], const boost::program_options::variables_map cmdvars)</td></tr>
<tr class="memdesc:a845c27cec3521110457cad602b519017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a control file for flow problems.  <br /></td></tr>
<tr class="separator:a845c27cec3521110457cad602b519017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6327ae6713d5425a738847908a99b874" id="r_a6327ae6713d5425a738847908a99b874"><td class="memTemplParams" colspan="2"><a id="a6327ae6713d5425a738847908a99b874" name="a6327ae6713d5425a738847908a99b874"></a>
template&lt;typename index&gt; </td></tr>
<tr class="memitem:a6327ae6713d5425a738847908a99b874"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inclusive_scan</b> (std::vector&lt; index &gt; &amp;v)</td></tr>
<tr class="separator:a6327ae6713d5425a738847908a99b874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78bfa159c96fc092c70308b27b569ed" id="r_ad78bfa159c96fc092c70308b27b569ed"><td class="memTemplParams" colspan="2"><a id="ad78bfa159c96fc092c70308b27b569ed" name="ad78bfa159c96fc092c70308b27b569ed"></a>
template&lt;typename index, typename allocator&gt; </td></tr>
<tr class="memitem:ad78bfa159c96fc092c70308b27b569ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inclusive_scan</b> (std::vector&lt; index, allocator &gt; &amp;v)</td></tr>
<tr class="separator:ad78bfa159c96fc092c70308b27b569ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4425cbe6d8db678f942e516b3efaaade" id="r_a4425cbe6d8db678f942e516b3efaaade"><td class="memTemplParams" colspan="2"><a id="a4425cbe6d8db678f942e516b3efaaade" name="a4425cbe6d8db678f942e516b3efaaade"></a>
template&lt;typename index&gt; </td></tr>
<tr class="memitem:a4425cbe6d8db678f942e516b3efaaade"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inclusive_scan</b> (const std::vector&lt; index &gt; &amp;v)</td></tr>
<tr class="separator:a4425cbe6d8db678f942e516b3efaaade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22543843630144db3b655a8df70e9e71" id="r_a22543843630144db3b655a8df70e9e71"><td class="memItemLeft" align="right" valign="top"><a id="a22543843630144db3b655a8df70e9e71" name="a22543843630144db3b655a8df70e9e71"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a22543843630144db3b655a8df70e9e71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mpi_all_reduce</b> (<a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a> *const arr, const <a class="el" href="#aaebf89314ef9893bfb577bc1551f8f9c">fint</a> count, MPI_Op op, MPI_Comm comm)</td></tr>
<tr class="separator:a22543843630144db3b655a8df70e9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75039235dfb69355663161a7af3e723d" id="r_a75039235dfb69355663161a7af3e723d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75039235dfb69355663161a7af3e723d">wait_for_debugger</a> ()</td></tr>
<tr class="memdesc:a75039235dfb69355663161a7af3e723d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until a debugger is attached and a variable is changed.  <br /></td></tr>
<tr class="separator:a75039235dfb69355663161a7af3e723d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ac776befc94847079c0bdc5a0ab017" id="r_aa2ac776befc94847079c0bdc5a0ab017"><td class="memItemLeft" align="right" valign="top"><a id="aa2ac776befc94847079c0bdc5a0ab017" name="aa2ac776befc94847079c0bdc5a0ab017"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_mpi_size</b> (MPI_Comm comm)</td></tr>
<tr class="separator:aa2ac776befc94847079c0bdc5a0ab017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54771a394793326acb3a88b23ada740f" id="r_a54771a394793326acb3a88b23ada740f"><td class="memItemLeft" align="right" valign="top"><a id="a54771a394793326acb3a88b23ada740f" name="a54771a394793326acb3a88b23ada740f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_mpi_rank</b> (const MPI_Comm comm)</td></tr>
<tr class="separator:a54771a394793326acb3a88b23ada740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0951734fac5c0ca812fd381173cae1e7" id="r_a0951734fac5c0ca812fd381173cae1e7"><td class="memTemplParams" colspan="2"><a id="a0951734fac5c0ca812fd381173cae1e7" name="a0951734fac5c0ca812fd381173cae1e7"></a>
template&lt;typename scalar&gt; </td></tr>
<tr class="memitem:a0951734fac5c0ca812fd381173cae1e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mpi_all_reduce</b> (scalar *const arr, const <a class="el" href="#aaebf89314ef9893bfb577bc1551f8f9c">fint</a> count, MPI_Op op, MPI_Comm comm)</td></tr>
<tr class="memdesc:a0951734fac5c0ca812fd381173cae1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for MPI allreduce from an array into itself. <br /></td></tr>
<tr class="separator:a0951734fac5c0ca812fd381173cae1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a53afb22868b17bae5d0a6e399952664d" id="r_a53afb22868b17bae5d0a6e399952664d"><td class="memItemLeft" align="right" valign="top"><a id="a53afb22868b17bae5d0a6e399952664d" name="a53afb22868b17bae5d0a6e399952664d"></a>
const boost::bimap&lt; <a class="el" href="#a56fad6cc480ce18470ad2623ce90708e">BCType</a>, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bcTypeMap</b> = createBCTypeMap()</td></tr>
<tr class="memdesc:a53afb22868b17bae5d0a6e399952664d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global bi-directional map for getting from the type enum to type string and vice-versa. <br /></td></tr>
<tr class="separator:a53afb22868b17bae5d0a6e399952664d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>/file /brief Implementation if spatial discretization for Euler/Navier-Stokes equations. /author Aditya Kashi</p>
<p>This file is part of FVENS. FVENS is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>FVENS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with FVENS. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a7a35881a045a640494a8d4fb72b3c5d0" name="a7a35881a045a640494a8d4fb72b3c5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a35881a045a640494a8d4fb72b3c5d0">&#9670;&#160;</a></span>DimMatrixArray</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7a35881a045a640494a8d4fb72b3c5d0">fvens::DimMatrixArray</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::vector&lt; Eigen::Matrix&lt;scalar,NDIM,NDIM&gt;,</div>
<div class="line">                                    Eigen::aligned_allocator&lt;Eigen::Matrix&lt;scalar,NDIM,NDIM&gt;&gt; &gt;</div>
</div><!-- fragment -->
<p>An array of fixed-size Eigen matrices each with the number of space dimensions as the size. </p>
<p>It is absolutely necessary to use Eigen::aligned_allocator for std::vector s of fixed-size vectorizable Eigen arrays; see <a href="http://eigen.tuxfamily.org/dox-devel/group__TopicStlContainers.html">this</a>. </p>

</div>
</div>
<a id="aaebf89314ef9893bfb577bc1551f8f9c" name="aaebf89314ef9893bfb577bc1551f8f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebf89314ef9893bfb577bc1551f8f9c">&#9670;&#160;</a></span>fint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="#aaebf89314ef9893bfb577bc1551f8f9c">fvens::fint</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer type to use for indexing etc. </p>
<p>Using signed types for this might be better than using unsigned types, eg., to iterate backwards over an entire array (down to index 0). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="aconstants_8hpp.html#a4d46ec685ad36cb4ac7e45bd8d8d30e9" title="MPI data type corresponding to fvens::a_int. Make sure to keep this in sync with a_int.">FVENS_MPI_INT</a> </dd></dl>

</div>
</div>
<a id="ad45362403189f6d521a8f6c00a101fc3" name="ad45362403189f6d521a8f6c00a101fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45362403189f6d521a8f6c00a101fc3">&#9670;&#160;</a></span>freal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">fvens::freal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The floating-point type to use for all float computations. </p>
<p>If this is changed, the appropriate PETSc library will be required. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="aconstants_8hpp.html#ad4cf87a4b4efb9ad1c6f3143147d8e91" title="MPI data type corresponding to fvens::freal. Make sure to change this whenever freal is changed.">FVENS_MPI_REAL</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a62d82727e2795e5f6c0c22251bd7ee87" name="a62d82727e2795e5f6c0c22251bd7ee87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d82727e2795e5f6c0c22251bd7ee87">&#9670;&#160;</a></span>compareMeshes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; bool, 8 &gt; fvens::compareMeshes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, 2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, 2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two meshes for equality. </p>
<dl class="section return"><dt>Returns</dt><dd>An array of booleans which represents whether the following, in order, are the same:<ul>
<li>number of elements</li>
<li>number of points</li>
<li>number of physical boundary faces</li>
<li>number of nodes per element for each element</li>
<li>number of faces per element for each element</li>
<li>element-point interconnectivity list</li>
<li>boundary faces' array along with boundary tags</li>
<li>coordinates of points </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afa3009dae36597fd895ac71d99adb7f1" name="afa3009dae36597fd895ac71d99adb7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3009dae36597fd895ac71d99adb7f1">&#9670;&#160;</a></span>computeViscousFlux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar, int ndim, int nvars, bool constVisc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fvens::computeViscousFlux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; scalar &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>physics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar</td>          <td class="paramname"><span class="paramname"><em>grad</em></span>[ndim][nvars], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>ul</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>ur</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *const __restrict</td>          <td class="paramname"><span class="paramname"><em>vflux</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes viscous flux across a face at one point. </p>
<p>Note that the flux computed here must then be integrated on the face and <em>subtracted from</em> the residual, where residual is defined as <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ r(u) = \sum_K \int_{\partial K} F \hat{n} d\gamma $" src="form_4.png" width="120" height="16"/></picture> (where $f K $f denotes a cell), ie, it is the sum of all <em>outgoing</em> fluxes from each cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physics</td><td>The gas physics context to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Normal vector to the face </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grad</td><td>Unique gradients of primitive 2 variables at the face quadrature point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ul</td><td>Left state of faces (conserved variables) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ul</td><td>Right state of faces (conserved variables) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vflux</td><td>On output, contains the viscous flux across the face </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48049d5eef41436341319cb2d523b0f8" name="a48049d5eef41436341319cb2d523b0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48049d5eef41436341319cb2d523b0f8">&#9670;&#160;</a></span>computeViscousFluxJacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar, int ndim, int nvars, bool constVisc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fvens::computeViscousFluxJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; scalar &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>jphysics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>ul</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>ur</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar</td>          <td class="paramname"><span class="paramname"><em>grad</em></span>[ndim][nvars], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar</td>          <td class="paramname"><span class="paramname"><em>dgradl</em></span>[ndim][nvars][nvars], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar</td>          <td class="paramname"><span class="paramname"><em>dgradr</em></span>[ndim][nvars][nvars], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *const __restrict</td>          <td class="paramname"><span class="paramname"><em>dvfi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *const __restrict</td>          <td class="paramname"><span class="paramname"><em>dvfj</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobians of the viscous flux w.r.t. left and right cell-centered states. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo</a></b></dt><dd>Test this routine </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jphysics</td><td>The physics context to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Normal vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ul</td><td>Left conserved state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ur</td><td>Right conserved state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grad</td><td>The unique gradient at the face </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dgradl</td><td>The Jacobian of the face gradient w.r.t. left conserved state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dgradr</td><td>The Jacobian of the face gradient w.r.t. right conserved state </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>dvfi Jacobian of viscous flux across the face w.r.t. left conserved state </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>dvfj Jacobian of viscous flux across the face w.r.t. right conserved state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85fd3df42a189c16a0fd8f059ca2af97" name="a85fd3df42a189c16a0fd8f059ca2af97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85fd3df42a189c16a0fd8f059ca2af97">&#9670;&#160;</a></span>constructMeshFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; fvens::constructMeshFlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfvens_1_1FlowParserOptions.html">FlowParserOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>mesh_suffix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a mesh for use in a fluid simulation. </p>
<p>Construct a mesh from the base mesh name in the <a class="el" href="structfvens_1_1FlowParserOptions.html">options database</a> and a suffix Reads the mesh, computes the face connectivity, reorders the cells if requested and sets up periodic boundaries if necessary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh_suffix</td><td>A string to concatenate to the mesh file name before passing to the mesh class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ce28ba01c56cbfb14ea947b344b954d" name="a0ce28ba01c56cbfb14ea947b344b954d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce28ba01c56cbfb14ea947b344b954d">&#9670;&#160;</a></span>create_const_flowBCs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, const <a class="el" href="classfvens_1_1FlowBC.html">FlowBC</a>&lt; scalar &gt; * &gt; fvens::create_const_flowBCs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structfvens_1_1FlowBCConfig.html">FlowBCConfig</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>conf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; scalar &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>physics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a1b2e55079609900426cd7d4fb7d36d07">NVARS</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>uinf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a set of pointers to immutable boundary condition objects, possibly of different types. </p>
<p>The BC objects are mapped to their corresponding boundary markers specified in the control file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>Boundary condition parameters read from control file </td></tr>
    <tr><td class="paramname">physics</td><td>Gas properties </td></tr>
    <tr><td class="paramname">uinf</td><td>Free-stream state in conserved variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4906c48ce25b4fa8cb3a7d8e46cb1fe" name="ab4906c48ce25b4fa8cb3a7d8e46cb1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4906c48ce25b4fa8cb3a7d8e46cb1fe">&#9670;&#160;</a></span>create_const_flowSpatialDiscretization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classfvens_1_1FlowFV__base.html">FlowFV_base</a>&lt; scalar &gt; * fvens::create_const_flowSpatialDiscretization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfvens_1_1FlowPhysicsConfig.html">FlowPhysicsConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pconf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfvens_1_1FlowNumericsConfig.html">FlowNumericsConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>nconf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an immutable spatial discretization for slow problems. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1c5cbc8295a2dd53a534d963a006e9a9" title="Creates the appropriate flow solver class.">create_mutable_flowSpatialDiscretization</a> Options controlling the numerical method </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Mesh context  </td></tr>
    <tr><td class="paramname">pconf</td><td>Physical data about the problem </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a748c7114efe2e6252930479473524cb2" name="a748c7114efe2e6252930479473524cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748c7114efe2e6252930479473524cb2">&#9670;&#160;</a></span>create_const_gradientscheme()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar, int nvars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classfvens_1_1GradientScheme.html">GradientScheme</a>&lt; scalar, nvars &gt; * fvens::create_const_gradientscheme </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>rc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>rcbp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a newly-created immutable gradient computation context. </p>
<p>Parameters are as explained for <a class="el" href="#af34bed1b743b6b7fd52c984cd49a4eda">create_mutable_gradientscheme</a> </p>

</div>
</div>
<a id="a94ece0b65a3a151f6c95920916a7674e" name="a94ece0b65a3a151f6c95920916a7674e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ece0b65a3a151f6c95920916a7674e">&#9670;&#160;</a></span>create_const_reconstruction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar, int nvars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classfvens_1_1SolutionReconstruction.html">SolutionReconstruction</a>&lt; scalar, nvars &gt; * fvens::create_const_reconstruction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>rc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>rcbp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1amat_1_1Array2d.html">amat::Array2d</a>&lt; scalar &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a></td>          <td class="paramname"><span class="paramname"><em>param</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an immutable solution reconstruction context. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af664e21c4eef2a91eca08bd96f67a18f" title="Returns a solution reconstruction context.">create_mutable_reconstruction</a> </dd></dl>

</div>
</div>
<a id="a6fbed4f807cbfd710dc987267d6e5a7a" name="a6fbed4f807cbfd710dc987267d6e5a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbed4f807cbfd710dc987267d6e5a7a">&#9670;&#160;</a></span>create_matrixfree_jacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nvars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a> fvens::create_matrixfree_jacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1Spatial.html">Spatial</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, nvars &gt; *const</td>          <td class="paramname"><span class="paramname"><em>spatial</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat *const</td>          <td class="paramname"><span class="paramname"><em>A</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup a matrix-free Mat for the Jacobian. </p>
<p>Sets up the matrix-free Jacobian with the spatial discretization as well as sets up the PETSc shell Mat with it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spatial</td><td>The spatial discretization context to associate with the matrix-free Jacobian </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>The Mat to setup </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c5cbc8295a2dd53a534d963a006e9a9" name="a1c5cbc8295a2dd53a534d963a006e9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5cbc8295a2dd53a534d963a006e9a9">&#9670;&#160;</a></span>create_mutable_flowSpatialDiscretization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfvens_1_1FlowFV__base.html">FlowFV_base</a>&lt; scalar &gt; * fvens::create_mutable_flowSpatialDiscretization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfvens_1_1FlowPhysicsConfig.html">FlowPhysicsConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pconf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfvens_1_1FlowNumericsConfig.html">FlowNumericsConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>nconf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the appropriate flow solver class. </p>
<p>This function is needed to instantiate the appropriate class from the <a class="el" href="classfvens_1_1FlowFV.html">FlowFV</a> template. Options controlling the numerical method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Mesh context  </td></tr>
    <tr><td class="paramname">pconf</td><td>Physical data about the problem </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af34bed1b743b6b7fd52c984cd49a4eda" name="af34bed1b743b6b7fd52c984cd49a4eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34bed1b743b6b7fd52c984cd49a4eda">&#9670;&#160;</a></span>create_mutable_gradientscheme()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar, int nvars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfvens_1_1GradientScheme.html">GradientScheme</a>&lt; scalar, nvars &gt; * fvens::create_mutable_gradientscheme </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>rc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>rcbp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a newly-created gradient computation context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Type of gradient scheme </td></tr>
    <tr><td class="paramname">m</td><td>Mesh context. Currently its scalar type has to be same as that of the gradients etc </td></tr>
    <tr><td class="paramname">rc</td><td>Array of cell centres all cells (including connectivity ghost cells); this must also currently have the same scalar type as the gradients. </td></tr>
    <tr><td class="paramname">rcbp</td><td>Array of cell centres of physical boundary ghost cells </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af664e21c4eef2a91eca08bd96f67a18f" name="af664e21c4eef2a91eca08bd96f67a18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af664e21c4eef2a91eca08bd96f67a18f">&#9670;&#160;</a></span>create_mutable_reconstruction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar, int nvars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfvens_1_1SolutionReconstruction.html">SolutionReconstruction</a>&lt; scalar, nvars &gt; * fvens::create_mutable_reconstruction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>rc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>rcbp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1amat_1_1Array2d.html">amat::Array2d</a>&lt; scalar &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a></td>          <td class="paramname"><span class="paramname"><em>param</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a solution reconstruction context. </p>
<p>Solution reconstruction here means computing the values of the conserved variables at faces from the cell-centred values and cell-centred gradients. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Type of scheme to use for reconstructing the solution </td></tr>
    <tr><td class="paramname">m</td><td>Mesh context. Currently its scalar type has to be same as that of the gradients etc. </td></tr>
    <tr><td class="paramname">rc</td><td>Array of cell centres all cells (including connectivity ghost cells); this must also currently have the same scalar type as the gradients. </td></tr>
    <tr><td class="paramname">rcbp</td><td>Array of cell centres of physical boundary ghost cells </td></tr>
    <tr><td class="paramname">gr</td><td>Coordinates of quadrature points at each face. They're generally the face centres. </td></tr>
    <tr><td class="paramname">param</td><td>A parameter that controls the behaviour of some limiters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a721b6f991550d7f5dac681acd2986ffe" name="a721b6f991550d7f5dac681acd2986ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721b6f991550d7f5dac681acd2986ffe">&#9670;&#160;</a></span>createGhostedSystemVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a> fvens::createGhostedSystemVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>nvars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec *const</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up global vectors with storage with ghost locations for connectivity boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nvars</td><td>Number of physical variables per grid location </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87df369a5f08b7cabc1d8e8acc3b5018" name="a87df369a5f08b7cabc1d8e8acc3b5018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87df369a5f08b7cabc1d8e8acc3b5018">&#9670;&#160;</a></span>createSystemVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a> fvens::createSystemVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>nvars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec *const</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Vec with one unknown per mesh cell. </p>
<p>Currently, a 'sequential' Vec is created. </p>

</div>
</div>
<a id="a4217115d355c835837c0f786c170ca69" name="a4217115d355c835837c0f786c170ca69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4217115d355c835837c0f786c170ca69">&#9670;&#160;</a></span>firstorder_spatial_numerics_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfvens_1_1FlowNumericsConfig.html">FlowNumericsConfig</a> fvens::firstorder_spatial_numerics_config </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfvens_1_1FlowParserOptions.html">FlowParserOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts some numerical settings for spatial discretization from the control options but sets others as appropriate for a first-order scheme </p>

</div>
</div>
<a id="a520c29030bbab3242026a7c771b80d95" name="a520c29030bbab3242026a7c771b80d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520c29030bbab3242026a7c771b80d95">&#9670;&#160;</a></span>fvens_throw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fvens::fvens_throw </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>ierr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an error from an error code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ierr</td><td>An expression which, if true, triggers the exception </td></tr>
    <tr><td class="paramname">str</td><td>A short string message describing the error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff434fb6c97868e0af8715f3811bf08e" name="aff434fb6c97868e0af8715f3811bf08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff434fb6c97868e0af8715f3811bf08e">&#9670;&#160;</a></span>getCellAdjLists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfvens_1_1ListOfArrays.html">ListOfArrays</a>&lt; <a class="el" href="#aaebf89314ef9893bfb577bc1551f8f9c">fint</a> &gt; fvens::getCellAdjLists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the adjacency lists of the graph respresented by cells of the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mesh; assumes that the elements-surrounding-elements array esuel is already computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb2aea8606c84e108e550d97a8fce148" name="abb2aea8606c84e108e550d97a8fce148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2aea8606c84e108e550d97a8fce148">&#9670;&#160;</a></span>getComponentsCartesian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fvens::getComponentsCartesian </td>
          <td>(</td>
          <td class="paramtype">const scalar</td>          <td class="paramname"><span class="paramname"><em>mag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>[NDIM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>[NDIM]&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the Cartesian components of a vector given its magnitude and direction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mag</td><td>Magnitude of the vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>Unit vector in the direction of the vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vec</td><td>Cartesian components of the vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7203e773c9efc1df783a28bded7859ca" name="a7203e773c9efc1df783a28bded7859ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7203e773c9efc1df783a28bded7859ca">&#9670;&#160;</a></span>getNormalizedFreeStreamVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; fvens::getNormalizedFreeStreamVector </td>
          <td>(</td>
          <td class="paramtype">const scalar</td>          <td class="paramname"><span class="paramname"><em>aoa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the unit vector along free-stream direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aoa</td><td>Angle of attack </td></tr>
    <tr><td class="paramname">beta</td><td>Sideslip angle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a252eb1b3e765cbc124c43f0680858c85" name="a252eb1b3e765cbc124c43f0680858c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252eb1b3e765cbc124c43f0680858c85">&#9670;&#160;</a></span>getPrimitive2StatesAndGradients()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar, int ndim, bool secondOrderRequested&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fvens::getPrimitive2StatesAndGradients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1IdealGasPhysics.html">IdealGasPhysics</a>&lt; scalar &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>physics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>ucl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>ucr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>gradl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>gradr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *const</td>          <td class="paramname"><span class="paramname"><em>uctl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *const</td>          <td class="paramname"><span class="paramname"><em>uctr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *const</td>          <td class="paramname"><span class="paramname"><em>gradtl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *const</td>          <td class="paramname"><span class="paramname"><em>gradtr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes primitive-2 variables and temperature grad from conserved variables and primitive grads. </p>
<p>The output variables can then be used to compute unique face gradients using finite volume techniques such as modified averaging, for example.</p>
<p>Corresponding input and output variables can point to the same locations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physics</td><td>The gas physics context to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucl</td><td>Cell-centred conserved variables on left side of the face </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucr</td><td>Cell-centred conserved variables on right side of the face </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gradl</td><td>Gradients of primitive variables in left cell; must be row-major ndim x nvars </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gradr</td><td>Gradients of primitive variables in right cell; must be row-major ndim x nvars </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>uctl On output, primitive 2 variables in left cell </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>uctr On output, primitive 2 variables in right cell </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>gradtl On output, primitive 2 gradients in left cell (row-major) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>gradtr On output, primitive 2 gradients in right cell (row-major)</td></tr>
  </table>
  </dd>
</dl>
<p>gradl and gradr can be nullptrs if second-order accuracy is not required, in which case gradtl and gradtr are not touched.</p>
<p>Note that &lsquo;primtive 2&rsquo; variables are density, velocities and temperature. </p>

</div>
</div>
<a id="acf1040148dc4a6ca117ec289fc83a507" name="acf1040148dc4a6ca117ec289fc83a507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1040148dc4a6ca117ec289fc83a507">&#9670;&#160;</a></span>getQuotientDerivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fvens::getQuotientDerivatives </td>
          <td>(</td>
          <td class="paramtype">const scalar</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>df</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar *const</td>          <td class="paramname"><span class="paramname"><em>dg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *const __restrict</td>          <td class="paramname"><span class="paramname"><em>dq</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the derivatives of f/g given the derivatives of f and g (for NVARS components) </p>
<dl class="section note"><dt>Note</dt><dd>The result is added to the output array dq; so prior contents will affect the outcome. </dd>
<dd>
It is possible for the output array dq to point to the same location as one of the input arrays. In that case, the entire array should overlap, NOT only a part of it. </dd></dl>

</div>
</div>
<a id="a17baf16252ebdf913380841016c6adda" name="a17baf16252ebdf913380841016c6adda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17baf16252ebdf913380841016c6adda">&#9670;&#160;</a></span>hybridLineReorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fvens::hybridLineReorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, 2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a></td>          <td class="paramname"><span class="paramname"><em>threshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const</td>          <td class="paramname"><span class="paramname"><em>ordering</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orders the mesh cells according to a hybrid of line ordering and some other specified ordering. </p>
<p>Divides the mesh cells into lines and points, determines the connectivity between lines and points and orders the lines and points according to some desired ordering. Cells within a line are ordered consecutively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mesh to be reordered </td></tr>
    <tr><td class="paramname">threshold</td><td>Local anisotropy threshold </td></tr>
    <tr><td class="paramname">ordering</td><td>The ordering to use for the lines and points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae57fac984b13e9dd7072123ff707ef60" name="ae57fac984b13e9dd7072123ff707ef60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57fac984b13e9dd7072123ff707ef60">&#9670;&#160;</a></span>initializeSystemVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fvens::initializeSystemVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfvens_1_1FlowParserOptions.html">FlowParserOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec *const</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a vector of size number of cells times the number of PDEs, and initialize it with free-stream values from control file options </p>

</div>
</div>
<a id="a0cbefb568aed4483bc28fc6cc4497914" name="a0cbefb568aed4483bc28fc6cc4497914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cbefb568aed4483bc28fc6cc4497914">&#9670;&#160;</a></span>levelSchedule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="#aaebf89314ef9893bfb577bc1551f8f9c">fint</a> &gt; fvens::levelSchedule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, 2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides mesh cells into levels within each of which no cell is coupled to another. </p>
<p>Returns a list of cell indices corresponding to the start of each level. The length of the list is one more than the number of levels. </p>

</div>
</div>
<a id="a79f20b2ca692b4786879b960c2ee4538" name="a79f20b2ca692b4786879b960c2ee4538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f20b2ca692b4786879b960c2ee4538">&#9670;&#160;</a></span>lineReorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fvens::lineReorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, 2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a></td>          <td class="paramname"><span class="paramname"><em>threshold</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an ordering where lines of strong coupling are identified and ordered consecutively. </p>
<p>The outline of the algorithm is taken from <a class="el" href="citelist.html#CITEREF_mavriplis_anisotropic">[7]</a>. However, that paper is is slightly ambiguous about the local anisotropy metric. We use the max face weight divided by the min face weight at each cell. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mesh to be reordered (it is assumed that 'elements surrounding elements' is available) </td></tr>
    <tr><td class="paramname">threshold</td><td>The lower limit for the local anisotropy metric for which lines will be extended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06634f6cec73c21ac8394b85c86167d4" name="a06634f6cec73c21ac8394b85c86167d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06634f6cec73c21ac8394b85c86167d4">&#9670;&#160;</a></span>mpi_throw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fvens::mpi_throw </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>ierr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an error from an error code related to MPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ierr</td><td>an expression which, if true, triggers the exception </td></tr>
    <tr><td class="paramname">str</td><td>a short string message describing the error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a845c27cec3521110457cad602b519017" name="a845c27cec3521110457cad602b519017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845c27cec3521110457cad602b519017">&#9670;&#160;</a></span>parse_flow_controlfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfvens_1_1FlowParserOptions.html">FlowParserOptions</a> fvens::parse_flow_controlfile </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::program_options::variables_map</td>          <td class="paramname"><span class="paramname"><em>cmdvars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a control file for flow problems. </p>
<p>Replaces some option values read from the control file with those read from the command line if the latter have been supplied by the user. </p>

</div>
</div>
<a id="a38d02934e9fc273ed7d5092c85413abd" name="a38d02934e9fc273ed7d5092c85413abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d02934e9fc273ed7d5092c85413abd">&#9670;&#160;</a></span>parseOptionalPetscCmd_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fvens::parseOptionalPetscCmd_bool </td>
          <td>(</td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>optionname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a boolean corresponding to an optional argument from the default PETSc options database. </p>
<p>Returns false if the option was not set or if it could not be extracted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optionname</td><td>The name of the option to get the value of; needs to include the preceding '-' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cb7b42d9f36998258171ee4aa4e0220" name="a1cb7b42d9f36998258171ee4aa4e0220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb7b42d9f36998258171ee4aa4e0220">&#9670;&#160;</a></span>parseOptionalPetscCmd_intArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; fvens::parseOptionalPetscCmd_intArray </td>
          <td>(</td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>optionname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>maxlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the arguments of an int array option from the default PETSc options database. </p>
<p>Does not throw if the requested option was not found; just returns an empty vector in that case. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxlen</td><td>Maximum number of entries expected in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe08cf3c6fd44941b3023293365128b1" name="abe08cf3c6fd44941b3023293365128b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe08cf3c6fd44941b3023293365128b1">&#9670;&#160;</a></span>parseOptionalPetscCmd_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal fvens::parseOptionalPetscCmd_real </td>
          <td>(</td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>optionname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscReal</td>          <td class="paramname"><span class="paramname"><em>defval</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optionally extracts a real corresponding to the argument from the default PETSc options database. </p>
<p>Ideally, we would have single function template for int and real, but for that we need &lsquo;if constexpr&rsquo; from C++ 17 which not all compilers have yet.</p>
<p>Throws an exception if the function to read the option fails, but not if it succeeds and reports that the option was not set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optionname</td><td>Name of the option to be extracted </td></tr>
    <tr><td class="paramname">defval</td><td>The default value to be assigned in case the option was not passed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9334ba9120098d4c9902d554f0841c3" name="aa9334ba9120098d4c9902d554f0841c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9334ba9120098d4c9902d554f0841c3">&#9670;&#160;</a></span>parsePetscCmd_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fvens::parsePetscCmd_bool </td>
          <td>(</td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>optionname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a boolean corresponding to the argument from the default PETSc options database. </p>
<p>Throws an exception if the option was not set or if it could not be extracted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optionname</td><td>The name of the option to get the value of; needs to include the preceding '-' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dfd8414d44b131a34b5185582487090" name="a4dfd8414d44b131a34b5185582487090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfd8414d44b131a34b5185582487090">&#9670;&#160;</a></span>parsePetscCmd_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fvens::parsePetscCmd_int </td>
          <td>(</td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>optionname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts an integer corresponding to the argument from the default PETSc options database. </p>
<p>Ideally, we would have single function template for int and real, but for that we need &lsquo;if constexpr&rsquo; from C++ 17 which not all compilers have yet.</p>
<p>Throws an exception if the option was not set or if it could not be extracted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optionname</td><td>The name of the option to get the value of; needs to include the preceding '-' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40941319ec81093b1e86aaefe3f3962b" name="a40941319ec81093b1e86aaefe3f3962b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40941319ec81093b1e86aaefe3f3962b">&#9670;&#160;</a></span>parsePetscCmd_intArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; fvens::parsePetscCmd_intArray </td>
          <td>(</td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>optionname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>maxlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the arguments of an int array option from the default PETSc options database. </p>
<p>Ideally, we would have single function template for int and real, but for that we need &lsquo;if constexpr&rsquo; from C++ 17 which not all compilers have yet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxlen</td><td>Maximum number of entries expected in the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector of array entries; its size is the number of elements read, no more </dd></dl>

</div>
</div>
<a id="a5604f61952376355ab5a774e6d8df38f" name="a5604f61952376355ab5a774e6d8df38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5604f61952376355ab5a774e6d8df38f">&#9670;&#160;</a></span>parsePetscCmd_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fvens::parsePetscCmd_string </td>
          <td>(</td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>optionname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a string corresponding to the argument from the default PETSc options database. </p>
<p>Throws a string exception if the option was not set or if it could not be extracted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optionname</td><td>The name of the option to get the value of; needs to include the preceding '-' </td></tr>
    <tr><td class="paramname">len</td><td>The max number of characters expected in the string value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68dd7a233fbbde39f38e87c400f7e9ce" name="a68dd7a233fbbde39f38e87c400f7e9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dd7a233fbbde39f38e87c400f7e9ce">&#9670;&#160;</a></span>petsc_throw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fvens::petsc_throw </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>ierr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>throw an error from an error code related to petsc </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ierr</td><td>an expression which, if true, triggers the exception </td></tr>
    <tr><td class="paramname">str</td><td>a short string message describing the error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5afd2a89ff132e171e8abec92062b58" name="af5afd2a89ff132e171e8abec92062b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5afd2a89ff132e171e8abec92062b58">&#9670;&#160;</a></span>preprocessMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a> fvens::preprocessMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, 2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes various entity lists required for mesh traversal, also reorders the cells if requested. </p>
<p>This can, and should, be called immediately after [reading](UMesh2dh::readMesh) the mesh. Does not compute [periodic boundary maps](UMesh2dh::compute_periodic_map); this must be done separately. </p>

</div>
</div>
<a id="a23f717f1c2f1915faf8292763d0f59fe" name="a23f717f1c2f1915faf8292763d0f59fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f717f1c2f1915faf8292763d0f59fe">&#9670;&#160;</a></span>readMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfvens_1_1MeshData.html">MeshData</a> fvens::readMesh </td>
          <td>(</td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>mfile</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a mesh from a file. </p>
<p>The file should be in either the Gmsh 2.0 format or the SU2 format The file extensions should be</p><ul>
<li>msh for Gmsh 2.0</li>
<li>su2 for SU2 format</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>For an SU2 mesh file, string marker names must be replaced with integers before this function is called on it. </dd></dl>

</div>
</div>
<a id="a825aed6e96e3c9d13d908980a6f333c5" name="a825aed6e96e3c9d13d908980a6f333c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825aed6e96e3c9d13d908980a6f333c5">&#9670;&#160;</a></span>reorderMeshPetsc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a> fvens::reorderMeshPetsc </td>
          <td>(</td>
          <td class="paramtype">const char *const</td>          <td class="paramname"><span class="paramname"><em>ordering</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1Spatial.html">Spatial</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, 1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; scalar, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders the mesh cells in a given ordering using PETSc. </p>
<p>Symmetric premutations only. </p><dl class="section warning"><dt>Warning</dt><dd>It is the caller's responsibility to recompute things that are affected by the reordering, such as UMesh2dh::compute_topological.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ordering</td><td>The ordering to use - "rcm" is recommended. See the relevant <a href="www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatOrderingType.html">page</a> in the PETSc manual for the full list. </td></tr>
    <tr><td class="paramname">sd</td><td><a class="el" href="classfvens_1_1Spatial.html" title="Base class for finite volume spatial discretization.">Spatial</a> discretization to be used to generate a Jacobian matrix </td></tr>
    <tr><td class="paramname">m</td><td>The mesh context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adeb6c0d2e0e53a2f95307404a8bf14c7" name="adeb6c0d2e0e53a2f95307404a8bf14c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb6c0d2e0e53a2f95307404a8bf14c7">&#9670;&#160;</a></span>setupSystemMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nvars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7f4b3b34266f058dfacb80a0899efa24">StatusCode</a> fvens::setupSystemMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; *const</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat *const</td>          <td class="paramname"><span class="paramname"><em>A</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up storage preallocation for sparse matrix formats. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Mesh context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>A The matrix to pre-allocate for</td></tr>
  </table>
  </dd>
</dl>
<p>We assume there's only 1 neighboring cell that's not in this subdomain </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo</a></b></dt><dd>TODO: Once a partitioned mesh is used, set the preallocation properly.</dd></dl>
<p>The type of sparse matrix is read from the PETSc options database, but only MPI matrices are supported. </p>

</div>
</div>
<a id="a75039235dfb69355663161a7af3e723d" name="a75039235dfb69355663161a7af3e723d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75039235dfb69355663161a7af3e723d">&#9670;&#160;</a></span>wait_for_debugger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fvens::wait_for_debugger </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until a debugger is attached and a variable is changed. </p>
<p>Only activated if environment variable FVENS_MPI_DEBUG is set. Waits until a variable called 'debugger_attached' is set to 1 using the attached debugger. </p><dl class="section note"><dt>Note</dt><dd>Compiles only on Unix-like systems. Ref: Tom Fogal. "Debugging MPI programs with the GNU debugger". Version 1.1.0. February 2014. <a href="http://www.sci.utah.edu/~tfogal/academic/Fogal-ParallelDebugging.pdf">http://www.sci.utah.edu/~tfogal/academic/Fogal-ParallelDebugging.pdf</a> </dd></dl>

</div>
</div>
<a id="a68442829966f7546c0947f021eb0c998" name="a68442829966f7546c0947f021eb0c998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68442829966f7546c0947f021eb0c998">&#9670;&#160;</a></span>writeMeshToVtu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fvens::writeMeshToVtu </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>fname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">fvens::UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a hybrid mesh in VTU format. </p>
<p>VTK does not have a 9-node quadrilateral, so we ignore the cell-centered note for output. </p>

</div>
</div>
<a id="af6c8bb9667214507dc15f5ccb55ca943" name="af6c8bb9667214507dc15f5ccb55ca943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c8bb9667214507dc15f5ccb55ca943">&#9670;&#160;</a></span>writeScalarsVectorToVtu_CellData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fvens::writeScalarsVectorToVtu_CellData </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>fname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1UMesh.html">UMesh</a>&lt; <a class="el" href="#ad45362403189f6d521a8f6c00a101fc3">freal</a>, <a class="el" href="aconstants_8hpp.html#a2b1fd2d28c6a7d4a3f7027cc1b6466f3">NDIM</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1amat_1_1Array2d.html">amat::Array2d</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>scaname</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfvens_1_1amat_1_1Array2d.html">amat::Array2d</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>vecname</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes multiple scalar data sets and one vector data set, all cell-centered data, to a file in VTU format. </p>
<p>If either x or y is a 0x0 matrix, it is ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>is the output vtu file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
